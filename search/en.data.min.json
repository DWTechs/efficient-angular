[{"id":0,"href":"/efficient-angular/rxjs/angular/","title":"Angular","parent":"RxJS","content":"Previous : Table of Contents\nAngular Angular makes use of observables as an interface to handle a variety of common asynchronous operations.\nHTTP Angular’s HttpClient returns observables from HTTP method calls. For instance, http.get(‘/api’) returns an observable. This provides several advantages over promise-based HTTP APIs:\nObservables do not mutate the server response (as can occur through chained .then() calls on promises). Instead, you can use a series of operators to transform values as needed. HTTP requests are cancellable through the unsubscribe() method. Requests can be configured to get progress event updates. Failed requests can be retried easily.\nRouter Router.events provides events as observables. You can use the filter() operator from RxJS to look for events of interest, and subscribe to them in order to make decisions based on the sequence of events in the navigation process.\nThe ActivatedRoute is an injected router service that makes use of observables to get information about a route path and parameters. For example, ActivatedRoute.url contains an observable that reports the route path or paths.\nReactive forms Reactive forms have properties that use observables to monitor form control values. The FormControl properties valueChanges and statusChanges contain observables that raise change events. Subscribing to an observable form-control property is a way of triggering application logic within the component class.\nExample: FormGroup contains one or more FormControls. In this example, we get the FormControl called \u0026ldquo;name\u0026rdquo;. Then we integrate the new value in the array at each change\nimport { FormGroup } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;my-component\u0026#39;, template: \u0026#39;MyComponent Template\u0026#39; }) export class MyComponent implements OnInit { nameChangeLog: string[] = []; heroForm!: FormGroup; ngOnInit() { this.logNameChange(); } logNameChange() { const nameControl = this.heroForm.get(\u0026#39;name\u0026#39;); nameControl?.valueChanges.subscribe( (value: string) =\u0026gt; this.nameChangeLog.push(value) ); } } AsyncPipe The async pipe subscribes to an Observable or Promise and returns the latest value it has emitted. When a new value is emitted, the async pipe marks the component to be checked for changes. When the component gets destroyed, the async pipe unsubscribes automatically to avoid potential memory leaks.\nExample This example binds a Promise to the view. Clicking the Resolve button resolves the promise.\n@Component({ selector: \u0026#39;async-promise-pipe\u0026#39;, template: `\u0026lt;div\u0026gt; \u0026lt;code\u0026gt;promise|async\u0026lt;/code\u0026gt;: \u0026lt;button (click)=\u0026#34;clicked()\u0026#34;\u0026gt;button\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;Wait for it... {{ greeting | async }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;` }) export class AsyncPromisePipeComponent { greeting: Promise\u0026lt;string\u0026gt;|null = null; arrived: boolean = false; private resolve: Function|null = null; constructor() { this.reset(); } reset() { this.arrived = false; this.greeting = new Promise\u0026lt;string\u0026gt;((resolve, reject) =\u0026gt; { this.resolve = resolve; }); } clicked() { if (this.arrived) { this.reset(); } else { this.resolve!(\u0026#39;hi there!\u0026#39;); this.arrived = true; } } } It\u0026rsquo;s also possible to use async with Observables. The example below binds the time Observable to the view. The Observable continuously updates the view with the current time.\n@Component({ selector: \u0026#39;async-observable-pipe\u0026#39;, template: `\u0026lt;div\u0026gt;\u0026lt;code\u0026gt;observable|async\u0026lt;/code\u0026gt;: Time: {{ time | async }}\u0026lt;/div\u0026gt;` }) export class AsyncObservablePipeComponent { time = new Observable\u0026lt;string\u0026gt;(observer =\u0026gt; { setInterval(() =\u0026gt; observer.next(new Date().toString()), 1000); }); } All subscriptions must be deleted getVehicle(idVehicle: number): void { // get the vehicle detail by id this.vehicleSubscribe = this.vehicleWebService.get(idVehicle).subscribe((vehicle) =\u0026gt; { this.vehicle = vehicle; }); } ngOnDestroy() { if(this.vehicleSubscribe){ this.vehicleSubscribe.unsubscribe(); } } Note that HttpClient requests are automatically unsubscribed once the response has been sent. So you do not need to manually unsubscribe it.\n"},{"id":1,"href":"/efficient-angular/basics/","title":"Basics","parent":"Efficient Angular","content":" Learn NPM https://www.npmjs.com/\nLearn Typescript All the Angular code snippets you will find online are written in Typescript. It is important that developers master it and always type the variables and objects they are working with.\nLearn Conventions variable name (camelCase): let nameVariable: string; observable name (camelCase): let nameObservable$: Observable\u0026lt;String\u0026gt;; All variables must have a type\nUse environment variables The environment variables allow to modify the behavior of the application according to the environment. By default on angular, they are stored in the src/environments folder. This folder contains two files:\nenvironment.ts, which contains the variables for the development mode environment.prod.ts, which contains the variables for the production mode. The use of these vartiables makes it easier to put the application into production by avoiding any unnecessary manipluation before installation on the server.\nLearn MVVM pattern The Model: This is the business data layer and is not linked to any specific graphical representation.\nThe View: It contains the structural definition of what users will see on the screen. It can contain static and dynamic content (animations and change states). It must not contain any application logic.\nThe View - Model: This component makes the link between the model and the view. It takes care of managing data links and possible conversions. This is where the binding comes in.\nMVVM is the acronym of : Model/View/View-Model.\nThe View always receives user actions and only interacts with the Model-View. The Model communicates with the server and notifies the Model View of its change.\nThe Model View takes care of :\nPresenting Model data to the View Receiving data changes from the View Asking the Model to change. The View is then no longer linked to the Model. Thus the Model-View takes care of the entire Model change cycle. It carries out both the reception and the sending of the data to the View. This is called \u0026ldquo;data binding\u0026rdquo;. The displayed information is linked between two entities and updated in real time.\nThis last mechanism is the key to the MVVM pattern. It allows us to decouple the different parts of our application by being able to make it evolve in a modular way.\nA single Model can notify several Model Views of its change. Thus these Model Views will in turn notify their view to refresh.\nUse Components A component is a reusable element of the application, consisting of a view and a set of processes associated with this view. As shown in the code below, it is a class that exposes a view and defines the way the user can interact with it.\nThe component thus brings together the view and the associated business logic within the same entity. This is a fundamental difference with AngularJS where the two logics are clearly separated and the business logic contained in the controller.\nMany similarities exist between Angular 2 components and AngularJS directives. Indeed, AngularJS directives also contain a view and associated processing. However, the Angular 2 components are independent.\nAngular 2 therefore simplifies the architecture of an AngularJS application, by gathering in a single entity the concepts of controller, scope and view: the component.\nThe directives still exist but they no longer contain a template and only allow you to remove or associate a particular behavior to a DOM element. Example: ngIf, ngFor\nThink Components The components are the keystone of Angular. Think about your component before you start development: the list of questions to answer before developing a new component can be found in the \u0026quot;development \u0026gt; Practices\u0026quot; section.\nMake the components small enough to be reusable elsewhere in the application, but don\u0026rsquo;t oversize them because too small components only make the code more complex. It takes some experience and common sense to group components logically, but it quickly becomes natural.\nWhen the component is identified, the input and output data must be documented.\nUse Typescript heritage If a functionality related to a view is used on several screens, you can create a base component that contains its common functionality. The other components will be able to \u0026ldquo;extend\u0026rdquo; this base component.\nUse Reactive forms In Angular, the same care has been applied to forms, and the framework gives us a nice way to write our forms. In fact, it gives us several ways! You can either write your form using only directives in your template: that’s the \u0026ldquo;template-driven\u0026rdquo; way. From our experience, it shines when you have a simple form, with not much validation.\nThe other way is the \u0026ldquo;code-driven\u0026rdquo; way, where you will write a description of the form in your component, then use directives to bind this form to the inputs/textareas/selects in your template. It’s more verbose, but also more powerful, especially if you want to do add custom validation, or to generate dynamic forms.\nWe encourage the use of the code-driven approach, more verbose but more powerful.\nUse Services Put all the logic into services. The model view should only contain code that is useful to the view\n"},{"id":2,"href":"/efficient-angular/ngrx/basics/","title":"Basics","parent":"NgRx","content":" Basics @ngrx/store Store is RxJS powered global state management for Angular applications, inspired by Redux. Store is a controlled state container designed to help write performant, consistent applications on top of Angular.\nKey concepts Actions describe unique events that are dispatched from components and services. State changes are handled by pure functions called reducers that take the current state and the latest action to compute a new state. Selectors are pure functions used to select, derive and compose pieces of state. State is accessed with the Store, an observable of state and an observer of actions.\nLocal state management NgRx Store is mainly for managing global state across an entire application. In cases where you need to manage temporary or local component state, consider using NgRx ComponentStore.\n"},{"id":3,"href":"/efficient-angular/rxjs/subjects/","title":"BehaviorSubject","parent":"RxJS","content":" Subjects It is the big thing of RxJS as it gives multicast abilities to observables.\nIt allows values to be multicasted to many Observers. While plain Observables are unicast.\nEvery Subject is an Observable. Given a Subject, you can subscribe to it, providing an Observer, which will start receiving values normally. From the perspective of the Observer, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a Subject.\nInternally to the Subject, subscribe does not invoke a new execution that delivers values. It simply registers the given Observer in a list of Observers, similarly to how addListener works.\nEvery Subject is an Observer. It is an object with the methods next(v), error(e), and complete(). To feed a new value to the Subject, just call next(theValue), and it will be multicasted to the Observers registered to listen to the Subject.\nimport { Subject } from \u0026#39;rxjs\u0026#39;; const subject = new Subject\u0026lt;number\u0026gt;(); // Observer A subject.subscribe({ next: (v) =\u0026gt; console.log(`observerA: ${v}`) }); // Observer 2 subject.subscribe({ next: (v) =\u0026gt; console.log(`observerB: ${v}`) }); subject.next(1); subject.next(2); // Logs: // observerA: 1 // observerB: 1 // observerA: 2 // observerB: 2 Since a Subject is an Observer, this also means you may provide a Subject as the argument to the subscribe of any Observable\nimport { Subject, from } from \u0026#39;rxjs\u0026#39;; const subject = new Subject\u0026lt;number\u0026gt;(); // Observer A subject.subscribe({ next: (v) =\u0026gt; console.log(`observerA: ${v}`) }); // Observer B subject.subscribe({ next: (v) =\u0026gt; console.log(`observerB: ${v}`) }); const observable = from([1, 2, 3]); // You can subscribe providing a Subject observable.subscribe(subject); // Logs: // observerA: 1 // observerB: 1 // observerA: 2 // observerB: 2 // observerA: 3 // observerB: 3 With the approach above, we essentially just converted a unicast Observable execution to multicast, through the Subject. This demonstrates how Subjects are the only way of making any Observable execution be shared to multiple Observers.\nThere are also a few specializations of the Subject type like BehaviorSubject, ReplaySubject.\nBehaviorSubject It has a notion of \u0026ldquo;the current value\u0026rdquo;. It stores the latest value emitted to its consumers, and whenever a new Observer subscribes, it will immediately receive the \u0026ldquo;current value\u0026rdquo; from the BehaviorSubject.\nBehaviorSubjects are useful for representing \u0026ldquo;values over time\u0026rdquo;.\nIn the following example, the BehaviorSubject is initialized with the value 0 which the first Observer receives when it subscribes. The second Observer receives the value 2 even though it subscribed after the value 2 was sent.\nimport { BehaviorSubject } from \u0026#39;rxjs\u0026#39;; // 0 is the initial value const subject = new BehaviorSubject(0); subject.subscribe({ next: (v) =\u0026gt; console.log(`observerA: ${v}`) }); subject.next(1); subject.next(2); subject.subscribe({ next: (v) =\u0026gt; console.log(`observerB: ${v}`) }); subject.next(3); // Logs // observerA: 0 // observerA: 1 // observerA: 2 // observerB: 2 // observerA: 3 // observerB: 3 BehaviorSubject has 3 specific features:\nIt needs an initial value as it must always return a value on subscription even if it hasn\u0026rsquo;t received a next(). Upon subscription, it returns the last value of the subject. At any point, you can retrieve its last value using the getValue() method. ReplaySubject A ReplaySubject is similar to a BehaviorSubject in that it can send old values to new subscribers, but it can also record a part of the Observable execution.\nA ReplaySubject records multiple values from the Observable execution and replays them to new subscribers.\nWhen creating a ReplaySubject, you can specify how many values to replay:\nimport { ReplaySubject } from \u0026#39;rxjs\u0026#39;; // buffer 3 values for new subscribers const subject = new ReplaySubject(3); // Observer A subject.subscribe({ next: (v) =\u0026gt; console.log(`observerA: ${v}`) }); subject.next(1); subject.next(2); subject.next(3); subject.next(4); // Observer B subject.subscribe({ next: (v) =\u0026gt; console.log(`observerB: ${v}`) }); subject.next(5); // Logs: // observerA: 1 // observerA: 2 // observerA: 3 // observerA: 4 // observerB: 2 // observerB: 3 // observerB: 4 // observerA: 5 // observerB: 5 You can also specify a window time in milliseconds, besides of the buffer size, to determine how old the recorded values can be. In the following example we use a large buffer size of 100, but a window time parameter of just 500 milliseconds.\nimport { ReplaySubject } from \u0026#39;rxjs\u0026#39;; const subject = new ReplaySubject(100, 500); // Observer A subject.subscribe({ next: (v) =\u0026gt; console.log(`observerA: ${v}`) }); let i = 1; setInterval(() =\u0026gt; subject.next(i++), 200); setTimeout(() =\u0026gt; { // Observer B subject.subscribe({ next: (v) =\u0026gt; console.log(`observerB: ${v}`) }); }, 1000); // Logs // observerA: 1 // observerA: 2 // observerA: 3 // observerA: 4 // observerA: 5 // observerB: 3 // observerB: 4 // observerB: 5 // observerA: 6 // observerB: 6 // ... Subject vs BehaviorSubject vs ReplaySubject Subject - a subscriber will only get published values that were emitted after the subscription. Does the subscriber need to know anything about previous values? If not, then you can use this. For example, with component-to-component communication. Say you have a component that publishes events for other components on a button click. You can use a service with a subject to communicate.\nBehaviorSubject - the last value is cached. A subscriber will get the latest value upon initial subscription. The semantics for this subject is to represent a value that changes over time. For example a logged in user. The initial user might be an anonymous user. But once a user logs in, then the new value is the authenticated user state. The BehaviorSubject is initialized with an initial value.\nReplaySubject - it can cache up to a specified number of emissions. Any subscribers will get all the cached values upon subscription.\nVoid subject Sometimes the emitted value doesn\u0026rsquo;t matter as much as the fact that a value was emitted.\nFor instance, the code below signals that one second has passed.\nconst subject = new Subject\u0026lt;void\u0026gt;(); setTimeout(() =\u0026gt; subject.next(), 1000); By declaring a void subject, you signal that the value is irrelevant. Only the event itself matters.\n"},{"id":4,"href":"/efficient-angular/rxjs/subscription/","title":"BehaviorSubject","parent":"RxJS","content":" Subscription an object that represents a disposable resource, usually the execution of an Observable. A Subscription has one important method, unsubscribe, that takes no argument and just disposes the resource held by the subscription.\nimport { interval } from \u0026#39;rxjs\u0026#39;; const observable = interval(1000); const subscription = observable.subscribe(x =\u0026gt; console.log(x)); // Later: // This cancels the ongoing Observable execution which // was started by calling subscribe with an Observer. subscription.unsubscribe(); Subscriptions can also be put together, so that a call to an unsubscribe() of one Subscription may unsubscribe multiple Subscriptions. You can do this by \u0026ldquo;adding\u0026rdquo; one subscription into another:\nimport { interval } from \u0026#39;rxjs\u0026#39;; const observable1 = interval(400); const observable2 = interval(300); const subscription = observable1.subscribe(x =\u0026gt; console.log(\u0026#39;first: \u0026#39; + x)); const childSubscription = observable2.subscribe(x =\u0026gt; console.log(\u0026#39;second: \u0026#39; + x)); subscription.add(childSubscription); setTimeout(() =\u0026gt; { // Unsubscribes BOTH subscription and childSubscription subscription.unsubscribe(); }, 1000); Subscriptions also have a remove(otherSubscription) method, in order to undo the addition of a child Subscription.\nThe unsubscribe method will therefore :\nunregister the callbacks: next, error and complete destroy the Observable (interrupt the processing done by the Observable) possibly free the memory if they are not referenced elsewhere. The unsubscribe is generally done :\nwhen a component is destroyed via the ngOnDestroy lifecycle hook. when an Observable has to replace another one (e.g. : launching a new search by a user or refreshing the content). "},{"id":5,"href":"/efficient-angular/best-practices/","title":"Best Practices","parent":"Efficient Angular","content":" Structure and naming Structure your application \u0026ldquo;LIFT\u0026rdquo; in mind: Locate code quickly, Identify the code at a glance, keep the Flattest structure you can, and Try to be DRY (don\u0026rsquo;t repeat yourself)\nLocate: locating the code must be intuitive and fast. This is really important when someone else will have to work on the application. Identify : name the file such that you instantly know what it contains and represents. Prefer long and descriptive names over abbreviations that makes no sense. Flat structure : the structure must be as flat as possible. It is much easier to search through a folder containing some files than a folder containing subfolders. Above 7 files, the human eyes will have some difficulties to scan the folder, in that case you can create subfolders. Try to be DRY (don’t repeat yourself) : do not be redundant in file names (no need to call a component \u0026ldquo;product-view.component.html\u0026rdquo;, the .html extension already indicates that it is a view). Split your code into features modules: the structure will be much more clear and you will have the possibility to implement lazy-loading.\nCreate one or several shared modules according to your needs, in order to group shared elements, and features used in several modules. For instance, you can create an AngularMaterialModule to store all imports and exports of all components from @angular/material. Another example would be a SharedModule to group reusable pieces of the application (lists, forms, generic dialogs\u0026hellip;).\nImplement data-services specifically designed to interact with backend.\nFollow conventional naming: first the name of the functionality with dash if needed, then its type (feature.type.ts). Conventional types are: .service, .component, .pipe, .module, et .directive.\nSome examples :\nproducts-list.component.ts product.component.ts products.module.ts products-routing.module.ts products.service.ts Do not hesitate to generate those files with the command \u0026rsquo;ng generate [component/service/module\u0026hellip;] [path]\u0026rsquo;, it will do everything for you.\nThe decorator must match to the file type, and the file must only contain one decorator. Do not mix several classes and interfaces in a single file. It would compromise readability and maintainability.\nChoose which state management strategy you need (ngrx, services, routing\u0026hellip;)\nGo for one solution between Template Driven Form and Reactive Form and use only one in the application to keep consistent.\nConfigure project to avoid relative paths like '../../../../' in imports for .ts et .scss files.\nangular.json\n(...) \u0026#34;sourceRoot\u0026#34;: \u0026#34;src\u0026#34;, (...) \u0026#34;stylePreprocessorOptions\u0026#34;: { \u0026#34;includePaths\u0026#34;: [ \u0026#34;src/app/styles\u0026#34;, ] }, (...) Performance Always unsubscribe from subscriptions. There are a few ways to do so, but you can for example set up an ObservableComponent to handle subscription destruction in a more generic way.\nUse trackBy in *ngFor loops to speed up rendering of big lists.\nAvoid too much logic in templates (see examples in examples part)\nManually handle change detection if needed (ChangeDetectionStrategy OnPush)\nDon\u0026rsquo;t create custom Pipes with a filtering or a sorting logic. These are expensive operations that you want to handle as few times as possible, for example in the component or in a service just before rendering the view.\nBe aware of animations that can impact the application fluidity.\nKeep an eye on external libraries that can have some functionalities with a strong impact on performance.\nExamples Example 1 Instead of:\n\u0026lt;p\u0026gt;Total guests : {{ total + 10 }}\u0026lt;/p\u0026gt; Go for:\n\u0026lt;p\u0026gt;Total : {{ totalGuests }}\u0026lt;/p\u0026gt; And then handle the operation in the controller (.ts file).\nOption 1: add a property that you can update manually according to the component logic.\nOption 2: use a getter\nget totalGuests(): number { return this.total + 10; } Example 2 \u0026lt;h1\u0026gt;{{ getTitle() }}\u0026lt;/h1\u0026gt; Write this:\n\u0026lt;h1\u0026gt;{{ title }}\u0026lt;/p\u0026gt; And update title in the controller when needed (maybe on the ngOnChanges lifecycle hook if it is an @Input, or on the ngOnInit if it never changes, or in some specific methods if necessary\u0026hellip;). Doing so, we assure that the template rendering won\u0026rsquo;t be slowed down by a function being executed all the time.\n"},{"id":6,"href":"/efficient-angular/build/","title":"Build","parent":"Efficient Angular","content":" Build the application Environment files The files describing each environment are stored in the directory :\nsrc\\environments For each environment, it is necessary to create a new file with the following format environment.XXXXX.ts. We will find inside all the constants necessary to use Angular on the different environments such as: DB, URL of the site,\u0026hellip;\nConfiguration : the configuration of the application is defined in angular.json where we will find all the definitions of the environments. For each configuration a new location must be created as in the example above with the \u0026ldquo;dev\u0026rdquo; or \u0026ldquo;pre-prod\u0026rdquo; configuration. Then it is possible to define different parameters in the configuration such as environment variables, redefine the output of the build outputPath, build parameters, internationalization\u0026hellip;\n\u0026#34;configurations\u0026#34;: { \u0026#34;dev\u0026#34;: { \u0026#34;fileReplacements\u0026#34;: [{ \u0026#34;replace\u0026#34;: \u0026#34;src/environments/environment.ts\u0026#34;, \u0026#34;with\u0026#34;: \u0026#34;src/environments/environment.dev.ts\u0026#34; }] }, \u0026#34;pre-prod\u0026#34;: { \u0026#34;fileReplacements\u0026#34;: [{ \u0026#34;replace\u0026#34;: \u0026#34;src/environments/environment.ts\u0026#34;, \u0026#34;with\u0026#34;: \u0026#34;src/environments/environment.ppr.ts\u0026#34; }] } } Builds cli : Build an application for production : $ ng build --prod Build for an environment (configuration) $ ng build --configuration=pre-prod Build an application with internationalisation options :\nhttps://angular.io/guide/i18n\n"},{"id":7,"href":"/efficient-angular/cli/","title":"CLI","parent":"Efficient Angular","content":" Angular CLI : Scaffold generation Create a feature module: Execute the command:\nng generate module features/{feature-name} --module=\u0026#34;app.module.ts\u0026#34; --routing Create a page of feature Executer la commande :\nng generate component features/{feature-name}/pages/{page-name} Create a component of feature Executer la commande :\nng generate component features/{feature-name}/components/{component-name} Create a service of feature Executer la commande :\nng generate service features/{feature-name}/shared/{service-name} Create a model of feature Executer la commande :\nng generate class features/{feature-name}/shared/{model-name} --type=model "},{"id":8,"href":"/efficient-angular/rxjs/operators/join-creation/combine-latest/","title":"CombineLatest","parent":"Operators","content":"Previous : Operators\nCombineLatest Combines multiple Observables to create an Observable whose values are calculated from the latest values of each of its input Observables.\nSyntax combineLatest\u0026lt;O extends ObservableInput\u0026lt;any\u0026gt;, R\u0026gt;(...args: any[]): Observable\u0026lt;R\u0026gt; | Observable\u0026lt;ObservedValueOf\u0026lt;O\u0026gt;[]\u0026gt; Parameters Description args Type: any[]. Returns Observable | Observable\u0026lt;ObservedValueOf[]\u0026gt;: An Observable of projected values from the most recent values from each input Observable, or an array of the most recent values from each input Observable.\nExample Combine a dictionary of Observables\nimport { combineLatest, of } from \u0026#39;rxjs\u0026#39;; import { delay, startWith } from \u0026#39;rxjs/operators\u0026#39;; const observables = { a: of(1).pipe(delay(1000), startWith(0)), b: of(5).pipe(delay(5000), startWith(0)), c: of(10).pipe(delay(10000), startWith(0)) }; const combined = combineLatest(observables); combined.subscribe(value =\u0026gt; console.log(value)); // Logs // {a: 0, b: 0, c: 0} immediately // {a: 1, b: 0, c: 0} after 1s // {a: 1, b: 5, c: 0} after 5s // {a: 1, b: 5, c: 10} after 10s Combine an array of Observables\nimport { combineLatest, of } from \u0026#39;rxjs\u0026#39;; import { delay, startWith } from \u0026#39;rxjs/operators\u0026#39;; const observables = [1, 5, 10].map( n =\u0026gt; of(n).pipe( delay(n * 1000), // emit 0 and then emit n after n seconds startWith(0), ) ); const combined = combineLatest(observables); combined.subscribe(value =\u0026gt; console.log(value)); // Logs // [0, 0, 0] immediately // [1, 0, 0] after 1s // [1, 5, 0] after 5s // [1, 5, 10] after 10s "},{"id":9,"href":"/efficient-angular/rxjs/operators/Join/combine-latest-all/","title":"combineLatestAll","parent":"Join","content":"Previous : Operators\ncombineLatestAll Flattens an Observable-of-Observables by applying combineLatest when the Observable-of-Observables completes.\nSyntax combineLatestAll\u0026lt;R\u0026gt;(project?: (...values: any[]) =\u0026gt; R) Parameters Description project Optional Default is undefined. Function to map the most recent values from each inner Observable into a new result. Takes each of the most recent values from each collected inner Observable as arguments, in order. Example Map two click events to a finite interval Observable, then apply combineLatestAll\nimport { fromEvent, interval } from \u0026#39;rxjs\u0026#39;; import { map, combineLatestAll, take } from \u0026#39;rxjs/operators\u0026#39;; const clicks = fromEvent(document, \u0026#39;click\u0026#39;); const higherOrder = clicks.pipe( map(ev =\u0026gt; interval(Math.random() * 2000).pipe(take(3)) ), take(2) ); const result = higherOrder.pipe( combineLatestAll() ); result.subscribe(x =\u0026gt; console.log(x)); "},{"id":10,"href":"/efficient-angular/rxjs/operators/Join/combine-latest-with/","title":"CombineLatestWith","parent":"Join","content":"Previous : Operators\ncombineLatestWith Create an observable that combines the latest values from all passed observables and the source into arrays and emits them.\nSyntax combineLatestWith\u0026lt;T, A extends readonly unknown[]\u0026gt;(...otherSources: any[]): OperatorFunction\u0026lt;T, Cons\u0026lt;T, A\u0026gt;\u0026gt; Parameters Description otherSources the other sources to subscribe to. Returns OperatorFunction\u0026lt;T, Cons\u0026lt;T, A\u0026raquo;: A function that returns an Observable that emits the latest emissions from both source and provided Observables.\nExample Simple calculation from two inputs.\n// Setup: Add two inputs to the page const input1 = document.createElement(\u0026#39;input\u0026#39;); document.body.appendChild(input1); const input2 = document.createElement(\u0026#39;input\u0026#39;); document.body.appendChild(input2); // Get streams of changes const input1Changes$ = fromEvent(input1, \u0026#39;change\u0026#39;); const input2Changes$ = fromEvent(input2, \u0026#39;change\u0026#39;); // Combine the changes by adding them together input1Changes$.pipe( combineLatestWith(input2Changes$), map(([e1, e2]) =\u0026gt; Number(e1.target.value) + Number(e2.target.value)), ) .subscribe(x =\u0026gt; console.log(x)); "},{"id":11,"href":"/efficient-angular/rxjs/common-use-cases/","title":"Common operators and how to use them","parent":"RxJS","content":" Table of contents Transformation map switchMap Filtering filter distinctUntilChanged takeUntil Combination combineLatest pairwise Utility tap Transformation map The map operator is a Transformation Operator. It takes values from one Observable, transforms them, and creates a new Observable that emits the transformed values.\nWith map, you can perform simple transformations to the values emitted by an Observable.\nLet\u0026rsquo;s take a look at a common example in Angular: we get a backend response, and want to extract a property from it.\nimport { map } from \u0026#39;rxjs/operators\u0026#39;; interface Response\u0026lt;T\u0026gt; { success: boolean; data: T; } (...) public getBooks(): Observable\u0026lt;Book[]\u0026gt; { return httpClient.get\u0026lt;Response\u0026lt;Book[]\u0026gt;\u0026gt;(\u0026#39;/books\u0026#39;).pipe( map((res: Response\u0026lt;Book[]\u0026gt;) =\u0026gt; res.data) // only returns \u0026#39;data\u0026#39; ); } switchMap switchMap receives the values emitted by an Observable, and then returns a new Observable from a different source.\nA common example of switchMap is the following situation:\nYou have a list of books ids in a select dropdown. When the user selects a value, selectedId$ emits a new value. You need to get the complete book object based on this new selectedId$ value.\nimport { switchMap } from \u0026#39;rxjs/operators\u0026#39;; (...) selectedId$: Subject\u0026lt;string\u0026gt; = new Subject(); selectedBook: Book; getBook(): void { this.selectedId$.pipe( // Listen to selectedId$ changes switchMap(id: string) =\u0026gt; this.booksService.getBook(id)) // Redirects to another observable (http request) ).subscribe(book =\u0026gt; this.selectedBook = book); // Get a book } Filtering filter filter is an operator which emit values that pass the provided condition. It is useful to filter values and subscribing only if it is needed. For example, maybe you don\u0026rsquo;t want to subscribe to a selectedBook$ observable when its value is null or undefined. You can use filter in this case:\nimport { filter } from \u0026#39;rxjs/operators\u0026#39;; (...) selectedBook$: Observable\u0026lt;Book\u0026gt; = this.booksService.book$; getBook(): void { this.selectedBook$.pipe( filter(book =\u0026gt; !!book) // returns false if book is null or undefined, and stops the observable here ).subscribe(book =\u0026gt; this.book = book); } distinctUntilChanged Taking the previous example, you maybe don\u0026rsquo;t want to pass twice in the subscribe when the value of selectedBook$ does not change.\nFor this, you can use distinctUntilChanged operator:\nimport { distinctUntilChanged } from \u0026#39;rxjs/operators\u0026#39;; (...) selectedBook$: Observable\u0026lt;Book\u0026gt; = this.booksService.book$; getBook(): void { this.selectedBook$.pipe( distinctUntilChanged() // stops if the previous and current values are the same ).subscribe(book =\u0026gt; this.book = book); } Note: distinctUntilChanged takes an optional callback as argument:\ngetBook(): void { this.selectedBook$.pipe( distinctUntilChanged((previousValue: Book, currentValue: Book) =\u0026gt; { return previousValue.id === currentValue.id; // will stops if ids are the same }) ).subscribe(book =\u0026gt; this.book = book); } There is an operator for simple comparison like this, distinctUntilKeyChanged:\nimport { distinctUntilKeyChanged } from \u0026#39;rxjs/operators\u0026#39;; (...) getBook(): void { this.selectedBook$.pipe( distinctUntilKeyChanged(\u0026#39;id\u0026#39;) // does the same as the previous example ).subscribe(book =\u0026gt; this.book = book); } takeUntil Emit values until provided observable emits.\nExample: manage unsubscriptions.\nimport { takeUntil } from \u0026#39;rxjs/operators\u0026#39;; (...) this.dataService.data$.pipe( takeUntil(this.destroyed$) // will unsubscribe when destroyed$ completes ).subscribe(data =\u0026gt; this.data = data); Combination combineLatest When any observable emits a value, emits the last emitted value from each.\nBe aware that combineLatest will not emit an initial value until each observable emits at least one value.\nThis operator is useful for example when we want to trigger a search based on reactive inputs values:\nimport { combineLatest } from \u0026#39;rxjs\u0026#39;; (...) combineLatest([ this.searchTextCtrl.valueChanges, this.dateRangeCtrl.valueChanges, this.author.valueChanges ]).subscribe(([ searchText, dateRange, author ]) =\u0026gt; this.results = this.getFilteredResults(searchText, dateRange, author)); pairwise pairwise operation allows to get the previous and current values from an observable as an array.\nFor example, we have a selectedBook$ observable, which emit its new value everytime it changes.\nWe want to perform a comparison of the last value and the current one, we can do so:\nimport { pairwise } from \u0026#39;rxjs/operators\u0026#39;; (...) this.selectedBook$.pipe( // For example, the previous value was \u0026#39;Harry Potter 1\u0026#39; and the new one is \u0026#39;1984\u0026#39; pairwise() ).subscribe(([previousValue, currentValue]) =\u0026gt; { // [\u0026#39;Harry Potter 1\u0026#39;, \u0026#39;1984\u0026#39;] // Do something here }); Utility tap tap allows you to perform actions or side effects on an Observable stream without modifying or altering the original stream. The values \u0026ldquo;pass-through\u0026rdquo; the tap Operator to the next Operator or Subscriber.\nimport { tap } from \u0026#39;rxjs/operators\u0026#39;; (...) public getBooks(): Observable\u0026lt;Book[]\u0026gt; { return httpClient.get\u0026lt;Book[]\u0026gt;(\u0026#39;/books\u0026#39;).pipe( tap((books) =\u0026gt; this.snackbar.open(`${books.length} books received!`)) // action performed without altering the observable ); } "},{"id":12,"href":"/efficient-angular/rxjs/operators/join-creation/concat/","title":"Concat","parent":"Operators","content":"Previous : Operators\nConcat Creates an output Observable which sequentially emits all values from the first given Observable and then moves on to the next.\nSyntax concat(...args: any[]): Observable\u0026lt;unknown\u0026gt; Parameters Description otherSources Other observable sources to subscribe to, in sequence, after the original source is complete. Returns Observable Observable which sequentially emits all values from the first given Observable and then moves on to the next.\nExample Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10\nimport { concat, interval } from \u0026#39;rxjs\u0026#39;; import { take } from \u0026#39;rxjs/operators\u0026#39;; const timer1 = interval(1000).pipe(take(10)); const timer2 = interval(2000).pipe(take(6)); const timer3 = interval(500).pipe(take(10)); const result = concat(timer1, timer2, timer3); result.subscribe(x =\u0026gt; console.log(x)); // results in the following: // (Prints to console sequentially) // -1000ms-\u0026gt; 0 -1000ms-\u0026gt; 1 -1000ms-\u0026gt; ... 9 // -2000ms-\u0026gt; 0 -2000ms-\u0026gt; 1 -2000ms-\u0026gt; ... 5 // -500ms-\u0026gt; 0 -500ms-\u0026gt; 1 -500ms-\u0026gt; ... 9 Concatenate 3 Observables\nExample import { concat, interval } from \u0026#39;rxjs\u0026#39;; import { take } from \u0026#39;rxjs/operators\u0026#39;; const timer1 = interval(1000).pipe(take(10)); const timer2 = interval(2000).pipe(take(6)); const timer3 = interval(500).pipe(take(10)); const result = concat(timer1, timer2, timer3); result.subscribe(x =\u0026gt; console.log(x)); // results in the following: // (Prints to console sequentially) // -1000ms-\u0026gt; 0 -1000ms-\u0026gt; 1 -1000ms-\u0026gt; ... 9 // -2000ms-\u0026gt; 0 -2000ms-\u0026gt; 1 -2000ms-\u0026gt; ... 5 // -500ms-\u0026gt; 0 -500ms-\u0026gt; 1 -500ms-\u0026gt; ... 9 Concatenate the same Observable to repeat it\nExample import { concat, interval } from \u0026#39;rxjs\u0026#39;; import { take } from \u0026#39;rxjs/operators\u0026#39;; const timer = interval(1000).pipe(take(2)); concat(timer, timer) // concatenating the same Observable! .subscribe( value =\u0026gt; console.log(value), err =\u0026gt; {}, () =\u0026gt; console.log(\u0026#39;...and it is done!\u0026#39;) ); // Logs: // 0 after 1s // 1 after 2s // 0 after 3s // 1 after 4s // \u0026#34;...and it is done!\u0026#34; also after 4s "},{"id":13,"href":"/efficient-angular/rxjs/operators/Join/concat-with/","title":"ConcatWith","parent":"Join","content":"Previous : Operators\nConcatWith Emits all of the values from the source observable, then, once it completes, subscribes to each observable source provided, one at a time, emitting all of their values, and not subscribing to the next one until it completes.\nSyntax concatWith\u0026lt;T, A extends readonly unknown[]\u0026gt;(...otherSources: any[]): OperatorFunction\u0026lt;T, T | A[number]\u0026gt; Parameters Description otherSources Other observable sources to subscribe to, in sequence, after the original source is complete. Returns A function that returns an Observable that concatenates subscriptions to the source and provided Observables subscribing to the next only once the current subscription completes.\nExample Listen for one mouse click, then listen for all mouse moves.\nimport { fromEvent } from \u0026#39;rxjs\u0026#39;; import { concatWith } from \u0026#39;rxjs/operators\u0026#39;; const clicks$ = fromEvent(document, \u0026#39;click\u0026#39;); const moves$ = fromEvent(document, \u0026#39;mousemove\u0026#39;); clicks$.pipe( map(() =\u0026gt; \u0026#39;click\u0026#39;), take(1), concatWith( moves$.pipe( map(() =\u0026gt; \u0026#39;move\u0026#39;) ) ) ) .subscribe(x =\u0026gt; console.log(x)); // \u0026#39;click\u0026#39; // \u0026#39;move\u0026#39; // \u0026#39;move\u0026#39; // \u0026#39;move\u0026#39; // ... "},{"id":14,"href":"/efficient-angular/ngrx/effects/install/","title":"Creating observables","parent":"NgRx","content":" Install "},{"id":15,"href":"/efficient-angular/ngrx/effects/overview/","title":"Creating observables","parent":"NgRx","content":" Overview "},{"id":16,"href":"/efficient-angular/ngrx/Store/actions/","title":"Creating observables","parent":"NgRx","content":" Actions Actions are one of the main building blocks in NgRx. Actions express unique events that happen throughout your application. From user interaction with the page, external interaction through network requests, and direct interaction with device APIs, these and more events are described with actions.\nActions are the inputs and outputs of many systems in NgRx. Actions help you to understand how events are handled in your application.\nThe Action interface An Action in NgRx is made up of a simple interface:\ninterface Action { type: string; } The type property is for describing the action that will be dispatched in your application. The value of the type comes in the form of [Source] Event and is used to provide a context of what category of action it is, and where an action was dispatched from. You add properties to an action to provide additional context or metadata for an action.\nListed below are examples of actions written as plain old JavaScript objects (POJOs):\n{ type: \u0026#39;[Auth API] Login Success\u0026#39; } This action describes an event triggered by a successful authentication after interacting with a backend API.\n{ type: \u0026#39;[Login Page] Login\u0026#39;, username: string; password: string; } This action describes an event triggered by a user clicking a login button from the login page to attempt to authenticate a user. The username and password are defined as additional metadata provided from the login page.\nWriting actions There are a few rules to writing good actions within your application.\nUpfront - write actions before developing features to understand and gain a shared knowledge of the feature being implemented. Divide - categorize actions based on the event source. Many - actions are inexpensive to write, so the more actions you write, the better you express flows in your application. Event-Driven - capture events not commands as you are separating the description of an event and the handling of that event. Descriptive - provide context that are targeted to a unique event with more detailed information you can use to aid in debugging with the developer tools.\nLet\u0026rsquo;s look at an example action of initiating a login request.\nlogin-page.actions.ts\nimport { createAction, props } from \u0026#39;@ngrx/store\u0026#39;; export const login = createAction( \u0026#39;[Login Page] Login\u0026#39;, props\u0026lt;{ username: string; password: string }\u0026gt;() ); The createAction function returns a function, that when called returns an object in the shape of the Action interface. The props method is used to define any additional metadata needed for the handling of the action. Action creators provide a consistent, type-safe way to construct an action that is being dispatched.\nUse the action creator to return the Action when dispatching.\nlogin-page.component.ts\nonSubmit(username: string, password: string) { store.dispatch(login({ username: username, password: password })); } The login action creator receives an object of username and password and returns a plain JavaScript object with a type property of [Login Page] Login, with username and password as additional properties.\nThe returned action has very specific context about where the action came from and what event happened.\nThe category of the action is captured within the square brackets []. The category is used to group actions for a particular area, whether it be a component page, backend API, or browser API. The Login text after the category is a description about what event occurred from this action. In this case, the user clicked a login button from the login page to attempt to authenticate with a username and password.\n"},{"id":17,"href":"/efficient-angular/ngrx/Store/install/","title":"Creating observables","parent":"NgRx","content":" Installation Installing with npm npm install @ngrx/store --save Installing with yarn yarn add @ngrx/store Installing with ng add If your project is using the Angular CLI 6+ then you can install the Store to your project with the following ng add command :\nng add @ngrx/store@latest Optional ng add flags path - path to the module that you wish to add the import for the StoreModule to. project - name of the project defined in your angular.json to help locating the module to add the StoreModule to. module - name of file containing the module that you wish to add the import for the StoreModule to. Can also include the relative path to the file. For example, src/app/app.module.ts; minimal - By default true, flag to only provide minimal setup for the root state management. Only registers StoreModule.forRoot() in the provided module with an empty object, and default runtime checks. statePath - The file path to create the state in. By default, this is reducers. stateInterface - The type literal of the defined interface for the state. By default, this is State. This command will automate the following steps:\nUpdate package.json \u0026gt; dependencies with @ngrx/store. Run npm install to install those dependencies. Update your src/app/app.module.ts \u0026gt; imports array with StoreModule.forRoot({}). ng add @ngrx/store@latest --minimal false This command will automate the following steps:\nUpdate package.json \u0026gt; dependencies with @ngrx/store. Run npm install to install those dependencies. Create a src/app/reducers folder, unless the statePath flag is provided, in which case this would be created based on the flag. Create a src/app/reducers/index.ts file with an empty State interface, an empty reducers map, and an empty metaReducers array. This may be created under a different directory if the statePath flag is provided. Update your src/app/app.module.ts \u0026gt; imports array with StoreModule.forRoot(reducers, { metaReducers }). If you provided flags then the command will attempt to locate and update module found by the flags. Routing sources : https://ngrx.io/guide/store/install\n"},{"id":18,"href":"/efficient-angular/ngrx/Store/reducer/","title":"Creating observables","parent":"NgRx","content":""},{"id":19,"href":"/efficient-angular/ngrx/Store/selector/","title":"Creating observables","parent":"NgRx","content":""},{"id":20,"href":"/efficient-angular/rxjs/observables/","title":"Creating observables","parent":"RxJS","content":" Observables A lazy Push collections of multiple values. It can be compared to other concepts like this :\nSINGLE MULTIPLE Pull Function Iterator Push Promise Observable Observables can return multiple values over time.\nPull versus Push Pull and Push are two different protocols that describe how a data Producer can communicate with a data Consumer.\nIn Pull systems, the Consumer determines when it receives data from the data Producer. The Producer itself is unaware of when the data will be delivered to the Consumer.\nEvery JavaScript Function is a Pull system. The function is a Producer of data, and the code that calls the function is consuming it by \u0026ldquo;pulling\u0026rdquo; out a single return value from its call.\nIn Push systems, the Producer determines when to send data to the Consumer. The Consumer is unaware of when it will receive that data.\nPromises are the most common type of Push system. A Promise (the Producer) delivers a resolved value to registered callbacks (the Consumers), but unlike functions, it is the Promise which is in charge of determining precisely when that value is \u0026ldquo;pushed\u0026rdquo; to the callbacks.\nPush Multiple values with observables Observables are a new Push system. It is a Producer of multiple values, \u0026ldquo;pushing\u0026rdquo; them to Observers (Consumers).\nA Function is a lazily evaluated computation that synchronously returns a single value on invocation. An iterator is a lazily evaluated computation that synchronously returns zero to (potentially) infinite values on iteration. A Promise is a computation that may (or may not) eventually return a single value asynchronously. An Observable is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it\u0026rsquo;s invoked onwards. Observables are created using new Observable or a creation operator. They are subscribed to with an Observer. They execute to deliver next / error / complete notifications to the Observer. And their execution may be disposed. These four aspects are all encoded in an Observable instance, but some of these aspects are related to other types, like Observer and Subscription.\nCreate and Subscribe Use the Observable constructor to create an observable. The constructor takes as its argument the subscriber function to run when the observable’s subscribe() method executes. A subscriber function receives an Observer object, and can publish values to the observer\u0026rsquo;s next() method.\nConvention : observables are named with a \u0026ldquo;$\u0026rdquo; at the end\nExample\n// This function runs when subscribe() is called function sequenceSubscriber(observer: Observer\u0026lt;number\u0026gt;) { // synchronously deliver 1, 2, and 3, then complete observer.next(1); observer.next(2); observer.next(3); observer.complete(); return {unsubscribe() {}}; } // Create a new Observable that will deliver the above sequence const sequence$ = new Observable(sequenceSubscriber); // execute the Observable and print the result of each notification sequence$.subscribe({ next(num) { console.log(num); }, complete() { console.log(\u0026#39;Finished sequence\u0026#39;); } }); // Logs: // 1 // 2 // 3 // Finished sequence See Observer for more info\nDisposing Observable Execution Because Observable Executions may be infinite, and it\u0026rsquo;s common for an Observer to want to abort execution in finite time, we need an API for canceling an execution. Since each execution is exclusive to one Observer only, once the Observer is done receiving values, it has to have a way to stop the execution, in order to avoid wasting computation power or memory resources.\nWhen observable.subscribe is called, the Observer gets attached to the newly created Observable execution. This call also returns an object, the Subscription:\nconst subscription = observable.subscribe(x =\u0026gt; console.log(x) ); The Subscription represents the ongoing execution, and has a minimal API which allows you to cancel that execution.\nimport { from } from \u0026#39;rxjs\u0026#39;; const observable$ = from([10, 20, 30]); const subscription = observable$.subscribe(x =\u0026gt; console.log(x) ); subscription$.unsubscribe(); See Subscription for more info\n"},{"id":21,"href":"/efficient-angular/rxjs/observer/","title":"Creating observables","parent":"RxJS","content":" Observer A consumer of values delivered by an Observable. Observers are simply a set of callbacks, one for each type of notification delivered by the Observable: next, error, and complete. The following is an example of a typical Observer object:\nconst observer = { next: x =\u0026gt; console.log(\u0026#39;Observer got a next value: \u0026#39; + x), error: err =\u0026gt; console.error(\u0026#39;Observer got an error: \u0026#39; + err), complete: () =\u0026gt; console.log(\u0026#39;Observer got a complete notification\u0026#39;), }; To use the Observer, provide it to the subscribe of an Observable:\nobservable.subscribe(observer); Observers are objects with three callbacks, one for each type of notification that an Observable may deliver.\nWhen subscribing to an Observable, you may also just provide the next callback as an argument, without being attached to an Observer object, for instance like this:\nobservable.subscribe(x =\u0026gt; console.log(\u0026#39;Observer got a next value: \u0026#39; + x)); "},{"id":22,"href":"/efficient-angular/rxjs/operators/creation/","title":"Creation","parent":"Operator","content":" Observables Table of Contents "},{"id":23,"href":"/efficient-angular/rxjs/operators/filtering/debounce/","title":"Debounce","parent":"Filtering","content":"Previous : Operators\nDebounce Emits a notification from the source Observable only after a particular time span determined by another Observable has passed without another source emission.\nSyntax debounce\u0026lt;T\u0026gt;(durationSelector: (value: T) =\u0026gt; ObservableInput\u0026lt;any\u0026gt;): MonoTypeOperatorFunction\u0026lt;T\u0026gt; Parameters Description durationSelector A function that receives a value from the source Observable, for computing the timeout duration for each source value, returned as an Observable or a Promise. Returns MonoTypeOperatorFunction: A function that returns an Observable that delays the emissions of the source Observable by the specified duration Observable returned by durationSelector, and may drop some values if they occur too frequently.\nExample Emit the most recent click after a burst of clicks\nimport { fromEvent, interval } from \u0026#39;rxjs\u0026#39;; import { scan, debounce } from \u0026#39;rxjs/operators\u0026#39;; const clicks = fromEvent(document, \u0026#39;click\u0026#39;); const result = clicks.pipe( scan((i) =\u0026gt; ++i, 1), debounce((i) =\u0026gt; interval(200 * i)) ); result.subscribe(x =\u0026gt; console.log(x)); "},{"id":24,"href":"/efficient-angular/rxjs/operators/filtering/debounce-time/","title":"DebounceTime","parent":"Filtering","content":"Previous : Operators\nDebounceTime Emits a notification from the source Observable only after a particular time span has passed without another source emission.\nSyntax debounceTime\u0026lt;T\u0026gt;(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction\u0026lt;T\u0026gt; Parameters Description dueTime The timeout duration in milliseconds (or the time unit determined internally by the optional scheduler) for the window of time required to wait for emission silence before emitting the most recent source value. scheduler optional Default is asyncScheduler. The SchedulerLike to use for managing the timers that handle the timeout for each value. Returns MonoTypeOperatorFunction: A function that returns an Observable that delays the emissions of the source Observable by the specified dueTime, and may drop some values if they occur too frequently.\nExample Emit the most recent click after a burst of clicks\nimport { fromEvent } from \u0026#39;rxjs\u0026#39;; import { debounceTime } from \u0026#39;rxjs/operators\u0026#39;; const clicks = fromEvent(document, \u0026#39;click\u0026#39;); const result = clicks.pipe(debounceTime(1000)); result.subscribe(x =\u0026gt; console.log(x)); "},{"id":25,"href":"/efficient-angular/rxjs/overview/","title":"Definition","parent":"RxJS","content":" Overview You will mainly use observables to allow asynchronous transmission of messages between parts of your application. In Angular you will use them via RxJS.\nRxJS is a library for composing asynchronous and event-based programs by using observable sequences.\nIt provides one core type, the Observable, satellite types (Observer, Subjects) and operators inspired by Array#extras (map, filter, reduce, every, etc) to allow handling asynchronous events as collections.\nIt combines the Observer pattern with the Iterator pattern and functional programming with collections to fill the need for a better way of managing sequences of events.\nThe essential concepts to solve async event management are:\nObservable: a function that can return several values over time. an invokable collection of future values or events. a lazy Push collections of multiple values. Observer: a collection of callbacks that knows how to listen to values delivered by the Observable. Subscription: the execution of an Observable. Operators: pure functions that enable a functional programming style of dealing with collections with operations like map, filter, concat, reduce, etc. Subject: equivalent to an EventEmitter, and the only way of multicasting a value or event to multiple Observers. An observable can provide several values of any type: literals, messages or events, depending on the context. Both configuration and deletion logic are handled by the observable, so your application code only has to worry about subscribing and unsubscribing.\nIn the Observer interface, there are three callback methods to handle the three types of notifications that an observable can send :\nnext : required. A handler for each delivered value. error : optional. A handler for an error notification. An error halts execution of the observable instance. complete : optional. A handler for the execution-complete notification. Delayed values can continue to be delivered to the next handler after execution is complete. First example Normally you register event listeners.\ndocument.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; console.log(\u0026#39;Clicked!\u0026#39;)); Using RxJS you create an observable instead, and subscribe to it.\nimport { fromEvent } from \u0026#39;rxjs\u0026#39;; fromEvent(document, \u0026#39;click\u0026#39;).subscribe(() =\u0026gt; console.log(\u0026#39;Clicked!\u0026#39;) ); Purity RxJS produces values using pure functions. Producing a code less prone to errors.\nNormally you would create an impure function, where other pieces of your code can mess up your state.\nlet count = 0; document.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; console.log(`Clicked ${++count} times`)); Using RxJS the state is isolated.\nimport { fromEvent } from \u0026#39;rxjs\u0026#39;; import { scan } from \u0026#39;rxjs/operators\u0026#39;; fromEvent(document, \u0026#39;click\u0026#39;) .pipe(scan(count =\u0026gt; count + 1, 0)) .subscribe(count =\u0026gt; console.log(`Clicked ${count} times`) ); Flow RxJS has a range of operators that helps control how the events flow through observables.\nThis is how you would allow at most one click per second, with plain JavaScript:\nlet count = 0; let rate = 1000; let lastClick = Date.now() - rate; document.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { if (Date.now() - lastClick \u0026gt;= rate) { console.log(`Clicked ${++count} times`); lastClick = Date.now(); } }); With RxJS:\nimport { fromEvent } from \u0026#39;rxjs\u0026#39;; import { throttleTime, scan } from \u0026#39;rxjs/operators\u0026#39;; fromEvent(document, \u0026#39;click\u0026#39;) .pipe( throttleTime(1000), scan(count =\u0026gt; count + 1, 0) ) .subscribe(count =\u0026gt; console.log(`Clicked ${count} times`) ); Values You can transform the values passed through your observables.\nHere\u0026rsquo;s how you can add the current mouse x position for every click, in plain JavaScript:\nlet count = 0; const rate = 1000; let lastClick = Date.now() - rate; document.addEventListener(\u0026#39;click\u0026#39;, event =\u0026gt; { if (Date.now() - lastClick \u0026gt;= rate) { count += event.clientX; console.log(count); lastClick = Date.now(); } }); With RxJS:\nimport { fromEvent } from \u0026#39;rxjs\u0026#39;; import { throttleTime, map, scan } from \u0026#39;rxjs/operators\u0026#39;; fromEvent(document, \u0026#39;click\u0026#39;) .pipe( throttleTime(1000), map(event =\u0026gt; event.clientX), scan((count, clientX) =\u0026gt; count + clientX, 0) ) .subscribe(count =\u0026gt; console.log(count)); "},{"id":26,"href":"/efficient-angular/rxjs/operators/utility/delay/","title":"Delay","parent":"Utility","content":"Previous : Operators\nDelay Delays the emission of items from the source Observable by a given timeout or until a given Date.\nSyntax delay\u0026lt;T\u0026gt;(due: number | Date, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction\u0026lt;T\u0026gt; Parameters Description due The delay duration in milliseconds (a number) or a Date until which the emission of the source items is delayed. scheduler Optional Default is asyncScheduler. The SchedulerLike to use for managing the timers that handle the time-shift for each item. Returns MonoTypeOperatorFunction: A function that returns an Observable that delays the emissions of the source Observable by the specified timeout or Date.\nExample delay each click by one second\nimport { fromEvent } from \u0026#39;rxjs\u0026#39;; import { delay } from \u0026#39;rxjs/operators\u0026#39;; const clicks = fromEvent(document, \u0026#39;click\u0026#39;); const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second delayedClicks.subscribe(x =\u0026gt; console.log(x)); "},{"id":27,"href":"/efficient-angular/directives/","title":"Directives","parent":"Efficient Angular","content":" Directives "},{"id":28,"href":"/efficient-angular/rxjs/operators/filtering/distinct/","title":"Distinct","parent":"Filtering","content":"Previous : Operators\nDistinct Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\nSyntax distinct(keySelector?, flushes?): Observable Parameters Description keySelector Optional Default is undefined. Function to select which value you want to check as distinct. flushes Optional Default is undefined. Observable for flushing the internal HashSet of the operator. Returns MonoTypeOperatorFunction: A function that returns an Observable that emits items from the source Observable with distinct values.\nExample import { of } from \u0026#39;rxjs\u0026#39;; import { distinct } from \u0026#39;rxjs/operators\u0026#39;; interface Person { age: number, name: string } of( { age: 4, name: \u0026#39;Foo\u0026#39;}, { age: 7, name: \u0026#39;Bar\u0026#39;}, { age: 5, name: \u0026#39;Foo\u0026#39;} ).pipe( distinct((p: Person) =\u0026gt; p.name) ) .subscribe(x =\u0026gt; console.log(x)); // Outputs // { age: 4, name: \u0026#39;Foo\u0026#39; } // { age: 7, name: \u0026#39;Bar\u0026#39; } "},{"id":29,"href":"/efficient-angular/rxjs/operators/filtering/distinct-until-changed/","title":"DistinctUntilChanged","parent":"Filtering","content":"Previous : Operators\nDistinctUntilChanged Only emit when the current value is different than the last.\nSyntax distinctUntilChanged\u0026lt;T, K\u0026gt;(comparator?: (previous: K, current: K) =\u0026gt; boolean, keySelector: (value: T) =\u0026gt; K = identity as (value: T) =\u0026gt; K): MonoTypeOperatorFunction\u0026lt;T\u0026gt; Returns MonoTypeOperatorFunction: A function that returns an Observable that emits items from the source Observable with distinct values based on the key specified.\nParameters Description comparator Optional Default is undefined. The operator takes an optional comparison function that will be called to test if an item is distinct from the previous item. The function receives the current and the previous values as parameters and must return a boolean value that determines whether or not that value should be emitted to the observer or be ignored. Since it’s a comparison function, if it returns true, it means that values are the same and hence the value is ignored, otherwise it’s sent to the observer. defaultValue Optional Default is undefined. Comparison function called to test if an item is distinct from the previous item in the source. Example // RxJS v6+ import { from } from \u0026#39;rxjs\u0026#39;; import { distinctUntilChanged } from \u0026#39;rxjs/operators\u0026#39;; // only output distinct values, based on the last emitted value const source$ = from([ { name: \u0026#39;Brian\u0026#39; }, { name: \u0026#39;Joe\u0026#39; }, { name: \u0026#39;Joe\u0026#39; }, { name: \u0026#39;Sue\u0026#39; } ]); source$ // custom compare for name .pipe(distinctUntilChanged((prev, curr) =\u0026gt; prev.name === curr.name)) // output: { name: \u0026#39;Brian }, { name: \u0026#39;Joe\u0026#39; }, { name: \u0026#39;Sue\u0026#39; } .subscribe(console.log); "},{"id":30,"href":"/efficient-angular/rxjs/operators/filtering/distinct-until-key-changed/","title":"DistinctUntilKeyChanged","parent":"Filtering","content":"Previous : Operators\nDistinctUntilKeyChanged Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item, using a property accessed by using the key provided to check if the two items are distinct.\nSyntax distinctUntilKeyChanged\u0026lt;T, K extends keyof T\u0026gt;(key: K, compare?: (x: T[K], y: T[K]) =\u0026gt; boolean): MonoTypeOperatorFunction\u0026lt;T\u0026gt; Parameters Description key String key for object property lookup on each item. defaultValue Optional Default is undefined. Comparison function called to test if an item is distinct from the previous item in the source. Returns MonoTypeOperatorFunction: A function that returns an Observable that emits items from the source Observable with distinct values based on the key specified.\nExample import { of } from \u0026#39;rxjs\u0026#39;; import { distinctUntilKeyChanged } from \u0026#39;rxjs/operators\u0026#39;; interface Person { age: number, name: string } of( { age: 4, name: \u0026#39;Foo\u0026#39;}, { age: 7, name: \u0026#39;Bar\u0026#39;}, { age: 5, name: \u0026#39;Foo\u0026#39;}, { age: 6, name: \u0026#39;Foo\u0026#39;}, ).pipe( distinctUntilKeyChanged(\u0026#39;name\u0026#39;), ) .subscribe(x =\u0026gt; console.log(x)); // displays: // { age: 4, name: \u0026#39;Foo\u0026#39; } // { age: 7, name: \u0026#39;Bar\u0026#39; } // { age: 5, name: \u0026#39;Foo\u0026#39; } "},{"id":31,"href":"/efficient-angular/ECMAScript/","title":"ECMAScript","parent":"Efficient Angular","content":" ECMAScript Documentation sources :\nw3schools\nBest Practices All the advices applied on Javascript can be transferred to other languages.\nVariable naming conventions All names start with a letter. The name must begin with a letter, a dollar sign $ or an underscore _. It must not begin with a number. We use camelCase for identifier names The name may contain letters, numbers, a dollar sign $ or an underscore _. You must not use a dash - or a period . In a variable name. You can\u0026rsquo;t use keywords like var or new. You must also not give a name that is already used or will soon be used by Javascript. Declarations on Top It is a good coding practice to put all declarations at the top of each script or function.\nThis will:\nGive cleaner code Provide a single place to look for local variables Make it easier to avoid unwanted (implied) global variables Reduce the possibility of unwanted re-declarations Short Functions, well-named and mono-task The short functions are easy to read and contain. The name of the function should be sufficient to understand what it does. A function that does only one thing is easier to reuse, test and name. A function should not change its input parameters. It is preferable that it returns a new value and that\u0026rsquo;s all it should do.\n// Pure function function add(a, b) { return a + b; } // Not pure function function add(a, b) { var x = a + b; console.log(x); // Doing other job than returning output return x; } Modules and single responsibility Divide code into small seperate modules where each module has a single functionality. A module will be easier to name, understand, test and reuse.\nDon\u0026rsquo;t Use new keyword Use {} instead of new Object() Use \u0026quot;\u0026quot; instead of new String() Use 0 instead of new Number() Use false instead of new Boolean() Use [] instead of new Array() Use /()/ instead of new RegExp() Use function (){} instead of new Function() var x1 = {}; // new object var x2 = \u0026#39;\u0026#39;; // new primitive string var x3 = 0; // new primitive number var x4 = false; // new primitive boolean var x5 = []; // new array object var x6 = /()/; // new regexp object var x7 = function() {}; // new function object Use === Comparison The == comparison operator always converts (to matching types) before comparison.\nThe === operator forces comparison of values and type:\n0 == \u0026#39;\u0026#39;; // true 1 == \u0026#39;1\u0026#39;; // true 1 == true; // true 0 === \u0026#39;\u0026#39;; // false 1 === \u0026#39;1\u0026#39;; // false 1 === true; // false Ask the right questions (before New functionalities) The development methodology is very important to avoid technical debt. The questions to ask before developing any new functionality are the following: The development process of a US or any new functionality is very important and must always follow the same steps. All developers must follow the same path and ask themselves thr same questions:\nWhat components are needed to create this functionality? Do they already exist ? Do they need to be modified ? How will the component be accessible ? From the menu, through routing ? After a user action on another component ? In which folder should this component be stored ? Is it necessary to outsource it ? What inputs and outputs are required ? What are the backend routes necessary for its operation ? Do they already exist ? Do they need to be modified ? Is it necessary to create a form ? What are the necessary validations? Is it necessary to import an external library ? Is this or a similar library already used in the project ? The development of the solution will be more serene when these issues have been addressed beforehand. The quality of the code is greatly affected.\nStructure the code Shared modules. Try to create modules that can be used more than once in the code. This reduces code duplication and facilitates maintenance.\nUse angular.json to build css files rather than importing files one by one into index.html.\nGlobal or local CSS. When writing CSS code, ask yourself if this style could be used in other modules. If so, write this code at the application level rather than at the module level. This will avoid duplication of code. You can override this code at the module level if there is a need for a small specific modification in a module.\nUse themes with SCSS. Create a file that contains all the variables for color, font, font size. This will help a lot with CSS maintenance and evolutions.\nMake comments The code must be accompanied by comments to promote understanding of the treatments for future developers who will be involved in the project\nUse Unit Tests To avoid regressions, the developer finishes his task by developing the unit test that will validate his code.\nEncouraging Factorisation It is important to factor all or part of the code when a lack of control is noticed. This eliminates dead code and copy/paste code. A tidy code is much easier to improve. Do not hesitate to spend some time factoring your code before finishing your task.\nManaging Dependencies Eliminate unnecessary or duplicate dependencies. Being careful to modify the code that depends on it.\nOutsource modules Code factoring or analysis before creating new functionality can lead to the outsourcing of modules. Outsourcing functionalities allows the use of the same module in several applications or in several versions of the same application. It is important to export these modules in ES6 format.\nLazy loading Lazy loading is a design patter commonly used in computer programming to defer initialization of an object until the point as which is needed. Do not load the entire application when the first page loads. It is best to load items only when they are needed during the life cycle of the application.\nImplementing code reviews All developers must deliver their code in a separate branch as a pull request. The lead dev has to review the code and approve it before it goes into the core. This ensures that every line of code has been proofread and helps correct errors that can\u0026rsquo;t be detected by the linter.\n"},{"id":32,"href":"/efficient-angular/","title":"Efficient Angular","parent":"","content":" Use Angular without hassle Understanding how to use Node.js will give a major boost to your daily work. It is a very powerful tool; And like every tool, it has been created mostly to make you gain time.\nBut if you and/or your team are not using it properly, Node.js can be a massive waste of time and money.\nThis guide will teach you how to Angular efficiently. The simple and most useful way. In order to make Node as effortless as possible in your daily work and focus on development of applications.\nGetting Started "},{"id":33,"href":"/efficient-angular/rxjs/error-handling/","title":"Error handling","parent":"RxJS","content":" Error handling You handle errors by specifying an error callback on the observer. Producing an error also causes the observable to clean up subscriptions and stop producing values.\nmyObservable.subscribe({ next(num) { console.log(\u0026#39;Next num: \u0026#39; + num)}, error(err) { console.log(\u0026#39;Received an error: \u0026#39; + err)} }); RxJS provides the catchError operator that lets you handle known errors in the observable recipe. For example, when an error is generated, if you detect this error and provide a default value, your flow continues to process the values.\nUse the retry operator before the catchError operator. It resubscribes to the original source observable, which can then re-run the full sequence of actions that resulted in the error.\nExample\n// Return \u0026#34;response\u0026#34; from the API. const apiData = ajax(\u0026#39;/api/data\u0026#39;).pipe( map((res: any) =\u0026gt; { if (!res.response) { throw new Error(\u0026#39;Value expected!\u0026#39;); } return res.response; }), retry(3), // Retry up to 3 times before failing catchError(() =\u0026gt; of([])) // If an error happens, return an empty array. ); "},{"id":34,"href":"/efficient-angular/rxjs/operators/filtering/filter/","title":"Filter","parent":"Filtering","content":"Previous : Operators\nFilter Filter items emitted by the source Observable by only emitting those that satisfy a specified predicate.\nSyntax filter\u0026lt;T\u0026gt;(predicate: (value: T, index: number) =\u0026gt; boolean, thisArg?: any): MonoTypeOperatorFunction\u0026lt;T\u0026gt; Parameters Description predicate A function that evaluates each value emitted by the source Observable. If it returns true, the value is emitted, if false the value is not passed to the output Observable. The index parameter is the number i for the i-th source emission that has happened since the subscription, starting from the number 0. thisArg Optional Default is undefined. An optional argument to determine the value of this in the predicate function. Returns MonoTypeOperatorFunction: A function that returns an Observable that emits items from the source Observable that satisfy the specified predicate.\nExample Emit only click events whose target was a DIV element\nimport { fromEvent } from \u0026#39;rxjs\u0026#39;; import { filter } from \u0026#39;rxjs/operators\u0026#39;; const clicks = fromEvent(document, \u0026#39;click\u0026#39;); const clicksOnDivs = clicks.pipe(filter(ev =\u0026gt; ev.target.tagName === \u0026#39;DIV\u0026#39;)); clicksOnDivs.subscribe(x =\u0026gt; console.log(x)); "},{"id":35,"href":"/efficient-angular/rxjs/operators/filtering/","title":"Filtering","parent":"Operator","content":" Observables Table of Contents "},{"id":36,"href":"/efficient-angular/rxjs/operators/filtering/first/","title":"First","parent":"Filtering","content":"Previous : Operators\nFirst Emits only the first value (or the first value that meets some condition) emitted by the source Observable.\nSyntax first\u0026lt;T, D\u0026gt;(predicate?: (value: T, index: number, source: Observable\u0026lt;T\u0026gt;) =\u0026gt; boolean, defaultValue?: D): OperatorFunction\u0026lt;T, T | D\u0026gt; Parameters Description predicate Optional condition to match defaultValue Optional value to emit if no value matches the condition Emits the first value if no predicate is present Emits the first matching value if the predicate is present Closes the stream after emitting a value If the source completes before emitting any matching value, then it raises the error notification. Returns OperatorFunction\u0026lt;T, T | D\u0026gt;: A function that returns an Observable that emits the first item that matches the condition.\nExample import { fromEvent } from \u0026#39;rxjs\u0026#39;; import { first } from \u0026#39;rxjs/operators\u0026#39;; const clicks = fromEvent(document, \u0026#39;click\u0026#39;); const result = clicks.pipe(first(ev =\u0026gt; ev.target.tagName === \u0026#39;DIV\u0026#39;)); result.subscribe(x =\u0026gt; console.log(x)); "},{"id":37,"href":"/efficient-angular/rxjs/operators/creation/from/","title":"From","parent":"Creation","content":"Previous : Operators\nFrom Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\nSyntax from\u0026lt;T\u0026gt;(input: ObservableInput\u0026lt;T\u0026gt;, scheduler?: SchedulerLike): Observable\u0026lt;T\u0026gt; Parameters Description input Type: ObservableInput. scheduler Optional Default is undefined. Type: SchedulerLike. Returns Observable:\nExample Converts an array to an Observable\nimport { from } from \u0026#39;rxjs\u0026#39;; const array = [10, 20, 30]; const result = from(array); result.subscribe(x =\u0026gt; console.log(x)); // Logs: // 10 // 20 // 30 "},{"id":38,"href":"/efficient-angular/rxjs/operators/creation/from-event/","title":"FromEvent","parent":"Creation","content":"Previous : Operators\nFromEvent Creates an Observable that emits events of a specific type coming from the given event target.\nSyntax fromEvent\u0026lt;T\u0026gt;(target: any, eventName: string, options?: EventListenerOptions | ((...args: any[]) =\u0026gt; T), resultSelector?: (...args: any[]) =\u0026gt; T): Observable\u0026lt;T\u0026gt; Parameters Description target The DOM EventTarget, Node.js EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to. eventName The event name of interest, being emitted by the target. options optional Default is undefined. Options to pass through to addEventListener resultSelector optional Default is undefined. Type: (...args: any[]) =\u0026gt; T. Returns Observable\u0026lt;T\u0026gt;: An observable that emits events of a specific type coming from the given event target.\nExamples Emits clicks happening on the DOM document\nimport { fromEvent } from \u0026#39;rxjs\u0026#39;; const clicks = fromEvent(document, \u0026#39;click\u0026#39;); clicks.subscribe(x =\u0026gt; console.log(x)); // Results in: // MouseEvent object logged to console every time a click // occurs on the document. Use addEventListener with capture option\nimport { fromEvent } from \u0026#39;rxjs\u0026#39;; const clicksInDocument = fromEvent(document, \u0026#39;click\u0026#39;, true); // note optional configuration parameter // which will be passed to addEventListener const clicksInDiv = fromEvent(someDivInDocument, \u0026#39;click\u0026#39;); clicksInDocument.subscribe(() =\u0026gt; console.log(\u0026#39;document\u0026#39;)); clicksInDiv.subscribe(() =\u0026gt; console.log(\u0026#39;div\u0026#39;)); // By default events bubble UP in DOM tree, so normally // when we would click on div in document // \u0026#34;div\u0026#34; would be logged first and then \u0026#34;document\u0026#34;. // Since we specified optional `capture` option, document // will catch event when it goes DOWN DOM tree, so console // will log \u0026#34;document\u0026#34; and then \u0026#34;div\u0026#34;. "},{"id":39,"href":"/efficient-angular/install/","title":"Install","parent":"Efficient Angular","content":" Start with Angular Set up environnement Nodejs install : https://nodejs.org/en/download/package-manager/\nInstall / cli update : https://github.com/angular/angular-cli\nGeneration of the Angular project For generate projet with sass and standard routage, we need to execute this :\nng new dream-app-front --style=scss --routing --prefix=dream Arborescence presentation App folder Content Content of folder is splite into three parts:\nFolder Description app/core/ All services related to the core. (authentication, etc\u0026hellip;) app/features Main features of the application. app/ui/ Common application components, pipes and guidelines App/ui folder content This folder content element the reusable of the application\nFolder Description app/ui/components Components can be reused throughout the application app/ui/directives Guidelines can be reused throughout the application app/ui/pipes Pipes reusable throughout the application App/features folder content This folder content different fonctionality of the application\nFolder / Files Description app/features/{name}\u0026gt;/components/ Feature-specific components app/features/{name}\u0026gt;/pages/ Contains the different pages of the feature app/features/{name}\u0026gt;/shared/ Shared services and models in the feature app/features/{name}/{name}-routing.module.ts Angular feature routing file app/features/{name}/{name}.module.ts Module Angular of the feature app/ |- app.module.ts |- app-routing.module.ts |- core/ |- auth/ |- auth.service.ts |- index.ts |- othermoduleofglobalservice/ |- features/ |- cars/ |- cars.module.ts |- cars-routing.module.ts |- components/ |- car-form/ |- car-details.component.html |- car-details.component.scss |- car-details.component.spec.ts |- car-details.component.ts |- cars-list/ |- cars-list.component.html |- cars-list.component.scss |- cars-list.component.spec.ts |- cars-list.component.ts |- pages/ |- car-edit/ |- car-edit.component.html |- car-edit.component.scss |- car-edit.component.spec.ts |- car-edit.component.ts |- cars/ |- cars.component.html |- cars.component.scss |- cars.component.spec.ts |- cars.component.ts |- shared/ |- cars.service.spec.ts |- cars.service.ts |- car.model.ts |- othermoduleofpages/ |- ui/ |- components/ |- nav-bar |- nav-bar.module.ts |- index.ts |- nav-bar/ |- nav-bar.component.html |- nav-bar.component.scss |- nav-bar.component.spec.ts |- nav-bar.component.ts |- directives |- pipes Shared Folders Shared folder pattern\n|- Shared |- enums |- models |- representations |- services\nAll files in these folders must be prefixed by the name of the feature. Exemple : Caddy-comand-type-enum.ts\nFolder Description Enums enums of feature Models the models of the feature, for example a model for a form,\u0026hellip; (component specific) Représentations the models from the backend (they are prefixed by representation at the end) Services we find the business services and web-services. For each microservice, there is a folder with a web-service file inside. Librairy essentials ng-bootstrap "},{"id":40,"href":"/efficient-angular/rxjs/operators/Join/","title":"Join","parent":"Operator","content":" Observables Table of Contents "},{"id":41,"href":"/efficient-angular/rxjs/operators/transformation/map/","title":"Map","parent":"Transformation","content":"Previous : Operators\nMap Applies a given project function to each value emitted by the source Observable, and emits the resulting values as an Observable.\nSyntax map\u0026lt;T, R\u0026gt;(project: (value: T, index: number) =\u0026gt; R, thisArg?: any): OperatorFunction\u0026lt;T, R\u0026gt; Parameters Description project The function to apply to each value emitted by the source Observable. The index parameter is the number i for the i-th emission that has happened since the subscription, starting from the number 0. thisArg Optional Default is undefined. An optional argument to define what this is in the project function. Returns OperatorFunction\u0026lt;T, R\u0026gt;: A function that returns an Observable that emits the values from the source Observable transformed by the given project function.\nExample Map every click to the clientX position of that click\nimport { fromEvent } from \u0026#39;rxjs\u0026#39;; import { map } from \u0026#39;rxjs/operators\u0026#39;; const clicks = fromEvent(document, \u0026#39;click\u0026#39;); const positions = clicks.pipe(map(ev =\u0026gt; ev.clientX)); positions.subscribe(x =\u0026gt; console.log(x)); "},{"id":42,"href":"/efficient-angular/directives/ngClass/","title":"ngClass","parent":"Directives","content":" ngClass Allows you to add and remove CSS classes on an HTML element.\nExample JavaScript\nlet isValid = false; let step = \u0026#39;step2\u0026#39;; let index = 1; HTML\n\u0026lt;div [ngClass]=\u0026#34;{\u0026#39;my_class1\u0026#39;: step === \u0026#39;step1\u0026#39;, \u0026#39;my_class2 my_class3\u0026#39; : step === \u0026#39;step2\u0026#39; }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- step === \u0026#39;step1\u0026#39; -\u0026gt; my_class1 ; step === \u0026#39;step2\u0026#39; -\u0026gt; my_class2 my_class3 --\u0026gt; \u0026lt;div [ngClass]=\u0026#34;{1 : \u0026#39;my_class1\u0026#39;, 2 : \u0026#39;my_class2\u0026#39;, 3 : \u0026#39;my_class3\u0026#39;}[index]\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- index === 1 -\u0026gt; my_class1 ; index === 2 -\u0026gt; my_class2 index === 3 -\u0026gt; my_class3 --\u0026gt; \u0026lt;div [ngClass]=\u0026#34;isValid ? \u0026#39;my_class1\u0026#39; : \u0026#39;my_class2\u0026#39;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- isValid = true -\u0026gt; my_class1 ; isValid = false -\u0026gt; my_class2 --\u0026gt; "},{"id":43,"href":"/efficient-angular/directives/ngFor/","title":"ngFor","parent":"Directives","content":" *ngFor The structural directive ngFor allows you to loop over an array and inject the elements into the DOM.\nIt is possible to retrieve other information such as the index of the element:\nindex : position of the element. odd : indicates if the element is at an odd position. even : indicates if the element is at an even position. first : indicates if the element is at the first position. last : indicates if the element is at the last position. Examples JavaScript\nexport interface Picture { address : string, src : string, width : number, height : number, text : string } let pictures : Picture[] = []; Example 1 HTML\n\u0026lt;div *ngFor=\u0026#34;let img of pictures\u0026#34; class=\u0026#34;img-container\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{ img.text }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; In this example, we have an array of pictures. With the ngFor directive, we will iterate on pictures. We display the text of each image.\nExample 2 HTML\n\u0026lt;div *ngFor=\u0026#34;let img of pictures ; let index = index\u0026#34; class=\u0026#34;img-container\u0026#34;\u0026gt; \u0026lt;!-- div 1 --\u0026gt; \u0026lt;div [style.background-image]=\u0026#34;\u0026#39;url(\u0026#39; + img.src + \u0026#39;)\u0026#39;\u0026#34; class=\u0026#34;picture\u0026#34; key=\u0026#34;index\u0026#34;\u0026gt; \u0026lt;!-- div 2 --\u0026gt; \u0026lt;div class=\u0026#34;image-click\u0026#34; (click)=\u0026#34;imageClick(index)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- div 3 --\u0026gt; \u0026lt;div\u0026gt;\u0026lt;p\u0026gt;{{ img.text }}\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;!-- div 4--\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; In this example, we have an array of pictures. With the ngFor directive, we will iterate on pictures. For each image contained in picture, div 1, 2, 3 and 4 will be duplicated. We also get the index of the current element in order to process the click on a picture (div 3).\nExample 3 HTML\n\u0026lt;div *ngFor=\u0026#34;let img of pictures; let index = index; let isFirst = first; let isOdd = odd;\u0026#34;\u0026gt; \u0026lt;!-- div 1 --\u0026gt; \u0026lt;span\u0026gt;{{ index }}\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;:\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;{{ img.text }}\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;( isFirst: {{ isFirst }}, isOdd: {{ isOdd }} )\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- output 0 : image text ( isFirst: true, isOdd: false )\u0026lt;br/\u0026gt; 1 : image text ( isFirst: false, isOdd: true ) --\u0026gt; Special note for performance: trackBy Working with list of data and *ngFor directive can quickly slow down your application.\nA solution to prevent performance issues is to use trackBy.\nBy default, Angular tracks items by object identity.\nSo, if the items are initiliazed with a request, and updated with a second request, items lose their identities and Angular must redraw them.\nThis produces big DOM manipulations, which can be very expensive.\nWe can help Angular to track items by providing a trackBy function.\ntrackBy takes a trackByFunction that will tell Angular how to track items.\nThe trackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.\nExample Here is a simple component that displays a list of books, and get new data by clicking on \u0026lsquo;Refresh list\u0026rsquo; button.\nimport { Component, OnInit } from \u0026#34;@angular/core\u0026#34;; @Component({ selector: \u0026#34;app-root\u0026#34;, styleUrls: [\u0026#34;./app.component.scss\u0026#34;], template: ` \u0026lt;button (click)=\u0026#34;getBooks()\u0026#34;\u0026gt;Refresh list\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li *ngFor=\u0026#34;let book of books;\u0026#34;\u0026gt;{{ book.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ` }) export class AppComponent implements OnInit { public books = []; ngOnInit() { this.getBooks(); } public getBooks() { this.books = this.books.length \u0026gt; 4 ? [ { id: 0, name: \u0026#39;Don Quixote - Miguel De Cervantes\u0026#39; }, { id: 1, name: \u0026#39;Robinson Crusoe - Daniel Defoe\u0026#39; }, { id: 2, name: \u0026#39;Frankenstein - Mary Shelley\u0026#39; }, { id: 3, name: \u0026#39;Anna Karenina - Leo Tolstoy\u0026#39; }, ] : [ { id: 0, name: \u0026#39;Don Quixote - Miguel De Cervantes\u0026#39; }, { id: 1, name: \u0026#39;Robinson Crusoe - Daniel Defoe\u0026#39; }, { id: 2, name: \u0026#39;Frankenstein - Mary Shelley\u0026#39; }, { id: 3, name: \u0026#39;Anna Karenina - Leo Tolstoy\u0026#39; }, { id: 4, name: \u0026#39;The Trial - Franz Kafka\u0026#39; }, ]; } } We can see Angular rebuilds the DOM at each refresh.\nNow let\u0026rsquo;s add trackBy:\nimport { Component, OnInit } from \u0026#34;@angular/core\u0026#34;; @Component({ selector: \u0026#34;app-root\u0026#34;, styleUrls: [\u0026#34;./app.component.scss\u0026#34;], template: ` \u0026lt;button (click)=\u0026#34;getBooks()\u0026#34;\u0026gt;Refresh list\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li *ngFor=\u0026#34;let book of books; trackBy: trackByFn\u0026#34;\u0026gt;{{ book.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ` }) export class AppComponent implements OnInit { public books = []; ngOnInit() { this.getBooks(); } public getBooks() { this.books = this.books.length \u0026gt; 4 ? [ { id: 0, name: \u0026#39;Don Quixote - Miguel De Cervantes\u0026#39; }, { id: 1, name: \u0026#39;Robinson Crusoe - Daniel Defoe\u0026#39; }, { id: 2, name: \u0026#39;Frankenstein - Mary Shelley\u0026#39; }, { id: 3, name: \u0026#39;Anna Karenina - Leo Tolstoy\u0026#39; }, ] : [ { id: 0, name: \u0026#39;Don Quixote - Miguel De Cervantes\u0026#39; }, { id: 1, name: \u0026#39;Robinson Crusoe - Daniel Defoe\u0026#39; }, { id: 2, name: \u0026#39;Frankenstein - Mary Shelley\u0026#39; }, { id: 3, name: \u0026#39;Anna Karenina - Leo Tolstoy\u0026#39; }, { id: 4, name: \u0026#39;The Trial - Franz Kafka\u0026#39; }, ]; } public trackByFn(index: number, item) { return index; } } Now, even when the collection changes, Angular can track which item has been inserted or deleted according to their unique identifier provided by the trackBy, and destroy only the items that changed.\n"},{"id":44,"href":"/efficient-angular/directives/ngIf/","title":"ngIf","parent":"Directives","content":" *ngIf This directive allows you to hide an element according to the associated expression.. It removes or adds the element in the DOM.\nNote: This directive adds or removes the element inside the DOM. If you just want to hide it, without removing it, use the CSS :\ndisplay:none means that the tag in question will not appear on the page at all (although you can still interact with it through the dom).There will be no space allocated for it between the other tags.\nJavaScript\nlet hide = false; HTML\n\u0026lt;h2 [ngClass]=\u0026#34;\u0026#39;not-displayed\u0026#39; : hide\u0026#34; class=\u0026#34;building-text\u0026#34;\u0026gt;Show this only if \u0026#34;show\u0026#34;\u0026lt;/h2\u0026gt; \u0026lt;!-- hide = true -\u0026gt; not-displayed -\u0026gt; display: none --\u0026gt; CSS\n.not-displayed { display: none; } visibility:hidden means that unlike display:none, the tag is not visible, but space is allocated for it on the page. The tag is rendered, it just isn\u0026rsquo;t seen on the page.\nJavaScript\nlet hide = false; HTML\n\u0026lt;h2 [ngStyle]=\u0026#34;{\u0026#39;visibility\u0026#39;:hide ? \u0026#39;hidden\u0026#39; : \u0026#39;visible\u0026#39; }\u0026#34; class=\u0026#34;building-text\u0026#34;\u0026gt;Show this only if \u0026#34;show\u0026#34;\u0026lt;/h2\u0026gt; \u0026lt;!-- hide = true -\u0026gt; visibility\u0026#39;:\u0026#39;hidden\u0026#39;; hide = false -\u0026gt; visibility\u0026#39;:\u0026#39;visible\u0026#39; --\u0026gt; Example JavaScript\nlet show = false; HTML\n\u0026lt;h2 *ngIf=\u0026#34;show\u0026#34; class=\u0026#34;building-text\u0026#34;\u0026gt;Show this only if \u0026#34;show\u0026#34;\u0026lt;/h2\u0026gt; \u0026lt;!-- show = false -\u0026gt; not displayed, not in the DOM --\u0026gt; in this example, the show variable is false, so the h2 title is not in the DOM. If the variable is set to true, the title will be added. it will be removed if it is set to false\n"},{"id":45,"href":"/efficient-angular/ngrx/","title":"NgRx","parent":"Efficient Angular","content":" Stores "},{"id":46,"href":"/efficient-angular/ngrx/effects/","title":"NgRx","parent":"NgRx","content":" Effects "},{"id":47,"href":"/efficient-angular/ngrx/Store/","title":"NgRx","parent":"NgRx","content":" Stores "},{"id":48,"href":"/efficient-angular/ngrx/Store/definition/","title":"NgRx Store Definition","parent":"NgRx","content":" Definition Store is RxJS powered global state management for Angular applications, inspired by Redux. Store is a controlled state container designed to help write performant, consistent applications on top of Angular.\nKey concepts Actions describe unique events that are dispatched from components and services. State changes are handled by pure functions called reducers that take the current state and the latest action to compute a new state. Selectors are pure functions used to select, derive and compose pieces of state. State is accessed with the Store, an observable of state and an observer of actions.\nLocal state management NgRx Store is mainly for managing global state across an entire application. In cases where you need to manage temporary or local component state, consider using NgRx ComponentStore.\nWhy use NgRx Store for State Management? NgRx Store provides state management for creating maintainable, explicit applications through the use of single state and actions in order to express state changes. In cases where you don\u0026rsquo;t need a global, application-wide solution to manage state, consider using NgRx ComponentStore which provides a solution for local state management.\nWhen Should I Use NgRx Store for State Management? In particular, you might use NgRx when you build an application with a lot of user interactions and multiple data sources, or when managing state in services are no longer sufficient.\nA good guideline that might help answer the question, \u0026ldquo;Do I need NgRx Store?\u0026rdquo; is the SHARI principle:\nShared: state that is accessed by many components and services.\nHydrated: state that is persisted and rehydrated from external storage.\nAvailable: state that needs to be available when re-entering routes.\nRetrieved: state that must be retrieved with a side-effect.\nImpacted: state that is impacted by actions from other sources.\nInconveniences/disadvantages However, realizing that using NgRx Store comes with some tradeoffs is also crucial. It is not meant to be the shortest or quickest way to write code. It also encourages the usage of many files.\nIt\u0026rsquo;s also important to consider the patterns implemented with NgRx Store. A solid understanding of RxJS and Redux will be very beneficial before learning to use NgRx Store and the other state management libraries.\n"},{"id":49,"href":"/efficient-angular/directives/ngStyle/","title":"ngStyle","parent":"Directives","content":" ngStyle The NgStyle directive lets you set a given DOM elements style properties.\nExample JavaScript\nlet stickerCompareData = false; let item: any = { color: \u0026#39;#000091\u0026#39;, text: \u0026#39;text\u0026#39;, label: \u0026#39;label\u0026#39; } HTML\n\u0026lt;div (click)=\u0026#34;setFullscreen()\u0026#34; [ngStyle]=\u0026#34;{\u0026#39;margin-left\u0026#39;:fullscreen ? \u0026#39;auto\u0026#39; : \u0026#39;24px\u0026#39; }\u0026#34;\u0026gt; \u0026lt;!-- fullscreen = true -\u0026gt; margin-left: auto ; fullscreen = false -\u0026gt; margin-left: 24px --\u0026gt; \u0026lt;div class=\u0026#34;square\u0026#34; [ngStyle]=\u0026#34;{\u0026#39;background-color\u0026#39;:item.color}\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- background-color: #000091 --\u0026gt; \u0026lt;div [ngStyle]=\u0026#34;stickerCompareData ? {\u0026#39;width\u0026#39;: \u0026#39;48%\u0026#39;} : {\u0026#39;width\u0026#39;: \u0026#39;100%\u0026#39;}\u0026#34;\u0026gt; \u0026lt;!-- stickerCompareData = true -\u0026gt; \u0026#39;width\u0026#39;: \u0026#39;48% ; fullscreen = false -\u0026gt; width\u0026#39;: \u0026#39;100% --\u0026gt; \u0026lt;div class=\u0026#34;sticker-content percentage\u0026#34; [ngStyle]=\u0026#34;{\u0026#39;width\u0026#39;: \u0026#39;48%\u0026#39;}\u0026#34;\u0026gt; \u0026lt;!-- width\u0026#39;: \u0026#39;48% --\u0026gt; "},{"id":50,"href":"/efficient-angular/rxjs/operators/creation/of/","title":"Of","parent":"Creation","content":"Previous : Operators\nOf Converts the arguments to an observable sequence.\nSyntax of\u0026lt;T\u0026gt;(...args: (SchedulerLike | T)[]): Observable\u0026lt;T\u0026gt; Parameters Description args Type: `(SchedulerLike Returns Observable: An Observable that emits the arguments described above and then completes.\nExample Emit the values 10, 20, 30\nimport { of } from \u0026#39;rxjs\u0026#39;; of(10, 20, 30) .subscribe( next =\u0026gt; console.log(\u0026#39;next:\u0026#39;, next), err =\u0026gt; console.log(\u0026#39;error:\u0026#39;, err), () =\u0026gt; console.log(\u0026#39;the end\u0026#39;), ); // Outputs // next: 10 // next: 20 // next: 30 // the end "},{"id":51,"href":"/efficient-angular/rxjs/operators/","title":"Operator","parent":"RxJS","content":" Operators Allow complex asynchronous code to be easily composed in a declarative manner (functional programming).\nRxJS provides natively more than a hundred operators.\nAn operator allows to define an Observable from another one by applying some transformations.\nExample\nimport { of } from \u0026#39;rxjs\u0026#39;; import { filter, map } from \u0026#39;rxjs/operators\u0026#39;; const squareOdd = of(1, 2, 3, 4, 5) .pipe( filter(n =\u0026gt; n % 2 !== 0), // odd values only map(n =\u0026gt; n * n) //Square odd values ); // Subscribe to get values squareOdd.subscribe(x =\u0026gt; console.log(x)); Pipe Pipeable Operators are the kind that can be piped to Observables. When called, they do not change the existing Observable instance. Instead, they return a new Observable, whose subscription logic is based on the first Observable.\nA Pipeable Operator is a function that takes an Observable as its input and returns another Observable. It is a pure operation: the previous Observable stays unmodified.\nA Pipeable Operator is essentially a pure function which takes one Observable as input and generates another Observable as output. Subscribing to the output Observable will also subscribe to the input Observable.\nCreate Creation Operators can be called as standalone functions to create a new Observable. For example: of(1, 2, 3) creates an observable that will emit 1, 2, and 3, one right after another.\nHigher-order Observables Observables most commonly emit ordinary values like strings and numbers, but sometimes it is necessary to handle Observables of Observables. For example, imagine you had an Observable emitting strings that were the URLs of files you wanted to see. The code might look like this:\nconst fileObservable = urlObservable.pipe(map((url) =\u0026gt; http.get(url))); http.get() returns an Observable (of string or string arrays probably) for each individual URL. Now you have an Observable of Observables, a higher-order Observable.\nBut how do you work with a higher-order Observable? Typically, by flattening. For example:\nconst fileObservable = urlObservable.pipe( map((url) =\u0026gt; http.get(url)), concatAll() ); The concatAll() operator subscribes to each \u0026ldquo;inner\u0026rdquo; Observable that comes out of the \u0026ldquo;outer\u0026rdquo; Observable, and copies all the emitted values until that Observable completes, and goes on to the next one. All of the values are in that way concatenated. Other useful flattening operators can be used.\nList of the most commonly used operators\nCreation operators Of From FromEvent Join Creation Operators CombineLatest Concat Transformation Operators Map SwitchMap Filtering Operators Debounce DebounceTime Distinct DistinctUntilChanged DistinctUntilKeyChanged Filter First TakeLast TakeUntil TakeWhile Join Operators CombineLatestAll CombineLatestWith ConcatWith Utility Operators Delay Tap find your operator https://rxjs-dev.firebaseapp.com/operator-decision-tree\n"},{"id":52,"href":"/efficient-angular/rxjs/operators/join-creation/","title":"Operators","parent":"Operator","content":" Observables Table of Contents "},{"id":53,"href":"/efficient-angular/ngrx/reducers/","title":"Reducers","parent":"NgRx","content":" Installation "},{"id":54,"href":"/efficient-angular/rxjs/","title":"RxJS","parent":"Efficient Angular","content":" RxJS "},{"id":55,"href":"/efficient-angular/ngrx/selectors/","title":"Selectors","parent":"NgRx","content":" Installation "},{"id":56,"href":"/efficient-angular/rxjs/operators/transformation/switch-map/","title":"SwitchMap","parent":"Transformation","content":"Previous : Operators\nSwitchMap Projects each source value to an Observable which is merged in the output Observable, emitting values only from the most recently projected Observable.\nSyntax switchMap\u0026lt;T, R, O extends ObservableInput\u0026lt;any\u0026gt;\u0026gt;(project: (value: T, index: number) =\u0026gt; O, resultSelector?: (outerValue: T, innerValue: ObservedValueOf\u0026lt;O\u0026gt;, outerIndex: number, innerIndex: number) =\u0026gt; R): OperatorFunction\u0026lt;T, ObservedValueOf\u0026lt;O\u0026gt; | R\u0026gt; Parameters Description project A function that, when applied to an item emitted by the source Observable, returns an Observable. resultSelector optional Optional. Default is undefined. Type: (outerValue: T, innerValue: ObservedValueOf, outerIndex: number, innerIndex: number) =\u0026gt; R. Returns OperatorFunction\u0026lt;T, ObservedValueOf | R\u0026gt;: A function that returns an Observable that emits the result of applying the projection function (and the optional deprecated resultSelector) to each item emitted by the source Observable and taking only the values from the most recently projected inner Observable.\nExample : Generate new Observable according to source Observable values\nimport { of } from \u0026#39;rxjs\u0026#39;; import { switchMap } from \u0026#39;rxjs/operators\u0026#39;; const switched = of(1, 2, 3).pipe(switchMap((x: number) =\u0026gt; of(x, x ** 2, x ** 3))); switched.subscribe(x =\u0026gt; console.log(x)); // outputs // 1 // 1 // 1 // 2 // 4 // 8 // ... and so on "},{"id":57,"href":"/efficient-angular/tags/","title":"Tags","parent":"Efficient Angular","content":""},{"id":58,"href":"/efficient-angular/rxjs/operators/filtering/take-last/","title":"TakeLast","parent":"Filtering","content":"Previous : Operators\nTakeLast Waits for the source to complete, then emits the last N values from the source, as specified by the count argument.\nSyntax takeLast\u0026lt;T\u0026gt;(count: number): MonoTypeOperatorFunction\u0026lt;T\u0026gt; Parameters Description count The maximum number of values to emit from the end of the sequence of values emitted by the source Observable. Returns MonoTypeOperatorFunction: A function that returns an Observable that emits at most the last count values emitted by the source Observable.\nExample Take the last 3 values of an Observable with many values\nimport { range } from \u0026#39;rxjs\u0026#39;; import { takeLast } from \u0026#39;rxjs/operators\u0026#39;; const many = range(1, 100); const lastThree = many.pipe(takeLast(3)); lastThree.subscribe(x =\u0026gt; console.log(x)); "},{"id":59,"href":"/efficient-angular/rxjs/operators/filtering/take-until/","title":"TakeUntil","parent":"Filtering","content":"Previous : Operators\nTakeUntil Emits the values emitted by the source Observable until a notifier Observable emits a value.\nSyntax takeUntil\u0026lt;T\u0026gt;(notifier: ObservableInput\u0026lt;any\u0026gt;): MonoTypeOperatorFunction\u0026lt;T\u0026gt; Parameters Description notifier The Observable whose first emitted value will cause the output Observable of takeUntil to stop emitting values from the source Observable. Returns MonoTypeOperatorFunction: A function that returns an Observable that emits the values from the source Observable until notifier emits its first value.\nExample Tick every second until the first click happens\nimport { fromEvent, interval } from \u0026#39;rxjs\u0026#39;; import { takeUntil } from \u0026#39;rxjs/operators\u0026#39;; const source = interval(1000); const clicks = fromEvent(document, \u0026#39;click\u0026#39;); const result = source.pipe(takeUntil(clicks)); result.subscribe(x =\u0026gt; console.log(x)); "},{"id":60,"href":"/efficient-angular/rxjs/operators/filtering/take-while/","title":"TakeWhile","parent":"Filtering","content":"Previous : Operators\nTakeWhile Emits values emitted by the source Observable so long as each value satisfies the given predicate, and then completes as soon as this predicate is not satisfied.\nSyntax takeWhile\u0026lt;T\u0026gt;(predicate: (value: T, index: number) =\u0026gt; boolean, inclusive: boolean = false): MonoTypeOperatorFunction\u0026lt;T\u0026gt; Parameters Description predicate A function that evaluates a value emitted by the source Observable and returns a boolean. Also takes the (zero-based) index as the second argument. inclusive optional Default is false. When set to true the value that caused predicate to return false will also be emitted. Returns MonoTypeOperatorFunction: A function that returns an Observable that emits values from the source Observable so long as each value satisfies the condition defined by the predicate, then completes.\nExample Emit click events only while the clientX property is greater than 200\nimport { fromEvent } from \u0026#39;rxjs\u0026#39;; import { takeWhile } from \u0026#39;rxjs/operators\u0026#39;; const clicks = fromEvent(document, \u0026#39;click\u0026#39;); const result = clicks.pipe(takeWhile(ev =\u0026gt; ev.clientX \u0026gt; 200)); result.subscribe(x =\u0026gt; console.log(x)); "},{"id":61,"href":"/efficient-angular/rxjs/operators/utility/tap/","title":"Tap","parent":"Utility","content":"Previous : Operators\nTap Used to perform side-effects for notifications from the source observable\nSyntax tap\u0026lt;T\u0026gt;(observerOrNext?: Partial\u0026lt;Observer\u0026lt;T\u0026gt;\u0026gt; | ((value: T) =\u0026gt; void), error?: (e: any) =\u0026gt; void, complete?: () =\u0026gt; void): MonoTypeOperatorFunction\u0026lt;T\u0026gt; Parameters Description observerOrNext Optional Optional. Default is undefined. A next handler or partial observer. error Optional Default is undefined. An error handler complete Optional Default is undefined. A completion handler Returns MonoTypeOperatorFunction: A function that returns an Observable identical to the source, but runs the specified Observer or callback(s) for each item.\nExample Check a random number before it is handled. Below is an observable that will use a random number between 0 and 1, and emit \u0026ldquo;big\u0026rdquo; or \u0026ldquo;small\u0026rdquo; depending on the size of that number. But we wanted to log what the original number was, so we have added a tap(console.log).\nimport { of } from \u0026#39;rxjs\u0026#39;; import { tap, map } from \u0026#39;rxjs/operators\u0026#39;; of(Math.random()).pipe( tap(console.log), map(n =\u0026gt; n \u0026gt; 0.5 ? \u0026#39;big\u0026#39; : \u0026#39;small\u0026#39;) ).subscribe(console.log); "},{"id":62,"href":"/efficient-angular/rxjs/operators/transformation/","title":"Transformation","parent":"Operator","content":" Observables Table of Contents "},{"id":63,"href":"/efficient-angular/rxjs/operators/utility/","title":"Utility","parent":"Operator","content":" Observables Table of Contents "},{"id":64,"href":"/efficient-angular/intro/","title":"What is Angular","parent":"Efficient Angular","content":"Node.js is an asynchronous event-driven JavaScript runtime, designed to build scalable networks. What this means is Node.js is designed to handle multiple concurrent requests without blocking.\nThis allows Node.js to handle thousands of concurrent requests making it very performant. It does this by using asynchronous function calls to complete tasks that would normally block the thread e.g. reading / writing to disk, making database calls etc. Node issues a call to a disk write function and carries on its own processing, when the activity completes node is notified via a call back function and resumes processing of the original request.\nNode is written in JavaScript allowing the same developer who works on the frontend to also work on the backend without having to learn a whole new language.\nThere are multiple plugin libraries for Node.js saving the developer time.\n"}]