<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RxJS on Efficient-angular</title><link>https://dwtechs.github.io/efficient-angular/rxjs/</link><description>Recent content in RxJS on Efficient-angular</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://dwtechs.github.io/efficient-angular/rxjs/index.xml" rel="self" type="application/rss+xml"/><item><title>Angular</title><link>https://dwtechs.github.io/efficient-angular/rxjs/angular/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-angular/rxjs/angular/</guid><description>Angular makes use of observables as an interface to handle a variety of common asynchronous operations.
HTTP Angular’s HttpClient returns observables from HTTP method calls. For instance, http.get(‘/api’) returns an observable. This provides several advantages over promise-based HTTP APIs:
Observables do not mutate the server response (as can occur through chained .then() calls on promises). Instead, you can use a series of operators to transform values as needed. HTTP requests are cancellable through the unsubscribe() method.</description></item><item><title>Common operators and how to use them</title><link>https://dwtechs.github.io/efficient-angular/rxjs/common-use-cases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-angular/rxjs/common-use-cases/</guid><description>Table of contents Transformation map switchMap Filtering filter distinctUntilChanged takeUntil Combination combineLatest pairwise Utility tap Transformation map The map operator is a Transformation Operator. It takes values from one Observable, transforms them, and creates a new Observable that emits the transformed values.
With map, you can perform simple transformations to the values emitted by an Observable.
Let&amp;rsquo;s take a look at a common example in Angular: we get a backend response, and want to extract a property from it.</description></item><item><title>Error handling</title><link>https://dwtechs.github.io/efficient-angular/rxjs/error-handling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-angular/rxjs/error-handling/</guid><description>You handle errors by specifying an error callback on the observer. Producing an error also causes the observable to clean up subscriptions and stop producing values.
myObservable.subscribe({ next(num) { console.log(&amp;#39;Next num: &amp;#39; + num)}, error(err) { console.log(&amp;#39;Received an error: &amp;#39; + err)} }); RxJS provides the catchError operator that lets you handle known errors in the observable recipe. For example, when an error is generated, if you detect this error and provide a default value, your flow continues to process the values.</description></item><item><title>Observables</title><link>https://dwtechs.github.io/efficient-angular/rxjs/observables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-angular/rxjs/observables/</guid><description>An observable is lazy Push collections of multiple values. It can be compared to other concepts like this :
SINGLE MULTIPLE Pull Function Iterator Push Promise Observable Observables can return multiple values over time.
Pull versus Push Pull and Push are two different protocols that describe how a data Producer can communicate with a data Consumer.
In Pull systems, the Consumer determines when it receives data from the data Producer. The Producer itself is unaware of when the data will be delivered to the Consumer.</description></item><item><title>Observer</title><link>https://dwtechs.github.io/efficient-angular/rxjs/observer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-angular/rxjs/observer/</guid><description>A consumer of values delivered by an Observable. Observers are simply a set of callbacks, one for each type of notification delivered by the Observable: next, error, and complete. The following is an example of a typical Observer object:
const observer = { next: x =&amp;gt; console.log(&amp;#39;Observer got a next value: &amp;#39; + x), error: err =&amp;gt; console.error(&amp;#39;Observer got an error: &amp;#39; + err), complete: () =&amp;gt; console.log(&amp;#39;Observer got a complete notification&amp;#39;), }; To use the Observer, provide it to the subscribe of an Observable:</description></item><item><title>Overview</title><link>https://dwtechs.github.io/efficient-angular/rxjs/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-angular/rxjs/overview/</guid><description>You will mainly use observables to allow asynchronous transmission of messages between parts of your application. In Angular you will use them via RxJS.
The essential concepts to solve async event management are:
Observable: a function that can return several values over time. an invokable collection of future values or events. a lazy Push collections of multiple values. Observer: a collection of callbacks that knows how to listen to values delivered by the Observable.</description></item><item><title>Subjects</title><link>https://dwtechs.github.io/efficient-angular/rxjs/subjects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-angular/rxjs/subjects/</guid><description>It is the big thing of RxJS as it gives multicast abilities to observables.
It allows values to be multicasted to many Observers. While plain Observables are unicast.
Every Subject is an Observable. Given a Subject, you can subscribe to it, providing an Observer, which will start receiving values normally. From the perspective of the Observer, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a Subject.</description></item><item><title>Subscription</title><link>https://dwtechs.github.io/efficient-angular/rxjs/subscription/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-angular/rxjs/subscription/</guid><description>an object that represents a disposable resource, usually the execution of an Observable. A Subscription has one important method, unsubscribe, that takes no argument and just disposes the resource held by the subscription.
import { interval } from &amp;#39;rxjs&amp;#39;; const observable = interval(1000); const subscription = observable.subscribe(x =&amp;gt; console.log(x)); // Later: // This cancels the ongoing Observable execution which // was started by calling subscribe with an Observer. subscription.unsubscribe(); Subscriptions can also be put together, so that a call to an unsubscribe() of one Subscription may unsubscribe multiple Subscriptions.</description></item></channel></rss>